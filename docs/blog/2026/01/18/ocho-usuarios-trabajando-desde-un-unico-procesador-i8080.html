<!DOCTYPE html>
<html lang="es">
  <head>
    <!--Source file: tecnologia/Sycor445.md-->
    <meta charset="utf-8" />
    <base href="/blog/" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ocho usuarios trabajando desde un √∫nico procesador i8080 | Comentarios</title>
    <meta property="og:title" content="Ocho usuarios trabajando desde un √∫nico procesador i8080" />
    <meta property="og:locale" content="es-ES" />
    <meta name="description" content="Un sorprendente minicomputador multi-usuario de oficina
" />
    <meta property="og:description" content="Un sorprendente minicomputador multi-usuario de oficina
" />
    <link rel="canonical" href="http://www.satyam.com.ar/blog/2026/01/18/ocho-usuarios-trabajando-desde-un-unico-procesador-i8080.html" />
    <meta property="og:url" content="http://www.satyam.com.ar/blog/2026/01/18/ocho-usuarios-trabajando-desde-un-unico-procesador-i8080.html" />
    <meta property="og:site_name" content="Comentarios" />
    <meta property="og:type" content="article" />
    <meta property="article:published_time" content="2026-01-18T00:00:00+01:00" />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Ocho usuarios trabajando desde un √∫nico procesador i8080" />
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "dateModified": "2026-01-18T00:00:00+01:00",
        "datePublished": "2026-01-18T00:00:00+01:00",
        "description": "Un sorprendente minicomputador multi-usuario de oficina
",
        "headline": "Ocho usuarios trabajando desde un √∫nico procesador i8080",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "http://www.satyam.com.ar/blog/2026/01/18/ocho-usuarios-trabajando-desde-un-unico-procesador-i8080.html"
        },
        "url": "http://www.satyam.com.ar/blog/2026/01/18/ocho-usuarios-trabajando-desde-un-unico-procesador-i8080.html"
      }
    </script>
    <link rel="stylesheet" href="assets/css/style.css" />
    <link
      type="application/atom+xml"
      rel="alternate"
      href="feed.xml"
      title="Comentarios"
    />
  </head>
  <body>
    <header class="site-header" role="banner">
      <div class="wrapper">
        <a class="site-title" rel="author" href="index.html">Comentarios</a>
        <nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path
                  d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"
                />
              </svg>
            </span>
          </label>

          <div class="trigger">
            
  <a class="page-link" href="../" title="Home page">Home</a>
  <a class="page-link" href="posts.html" title="Art√≠culos por fecha">Archivo</a>
  <a class="page-link" href="categories.html" title="Art√≠culos por etiqueta">
    Etiquetas
  </a>

            <form
              id="searchform"
              method="get"
              action="https://www.google.com/search"
              target="_blank"
            >
              <input type="text" name="q" id="s" size="15" />
              <input type="submit" name="submit" value="üîç" />
              <input type="hidden" name="as_sitesearch" value="satyam.com.ar" />
            </form>
          </div>
        </nav>
      </div>
    </header>
    <main class="page-content" aria-label="Content" lang="es-ES">
      <div class="wrapper">
        <article
          class="post h-entry"
          itemscope
          itemtype="http://schema.org/BlogPosting"
        >
          <header class="post-header">
            <h1 class="post-title p-name" itemprop="name headline">
              Ocho usuarios trabajando desde un √∫nico procesador i8080
            </h1>
            <div class="post-meta">
  <div class="date-published">
    Publicado el: 
    <time  datetime="2026-01-18T00:00:00+01:00" itemprop="datePublished">
      18 / Enero / 2026
    </time>
  </div>
  <div class="post-cats">Archivado bajo: <a
href="categories.html#Historia_Informatica"
rel="category tag"
>
Historia / Inform√°tica
</a>
,
<a href="categories.html#Tecnologia" rel="category tag">
Tecnolog√≠a
</a>
</div>
</div>

          </header>

          <div
            class="post-content e-content "
            itemprop="articleBody"
          >
            <p>Un sorprendente minicomputador multi-usuario de oficina</p>
<blockquote>
<p>Este art√≠culo es la versi√≥n en castellano, actualizada, del <a href="https://satyam.com.ar/blog/2021/11/06/eight-users-working-from-a-single-i8080-processor.html">original en ingl√©s</a>.</p>
</blockquote>
<p>La mayor√≠a de los usuarios de Windows saben que el procesador que lo ejecuta es un procesador Intel x86 o compatible, que proviene de una l√≠nea que comenz√≥ con el i8086, el primero de los microprocesadores de 16 bits de Intel, de all√≠ la <code>i</code> inicial. Le sucedieron el i80186, el i80286, etc. Eso es lo que representa la &quot;x&quot; en &quot;x86&quot;, el d√≠gito central que va aumentando en n√∫mero, que eliminaron cuando decidieron que ya no pod√≠an seguir con ese sistema de numeraci√≥n y empezaron a darles nombres, algo que comenz√≥ con el Intel Pentium, que de otro modo habr√≠a sido un i80586.</p>
<p>Aunque m√°s tarde pasaron a arquitecturas de 32 y 64 bits, el conjunto de instrucciones b√°sicas, los c√≥digos binarios reales que le indican al procesador qu√© hacer, se derivan del procesador i8086 original.</p>
<p>El i8086 no fue el primer procesador de Intel. De hecho, comenz√≥ con el i4004 , un procesador de 4 bits. La cantidad de bits de un procesador es el tama√±o del conjunto de bits con los que puede operar simult√°neamente. Con 4 bits, se tienen 2‚Å¥ s√≠mbolos , es decir, 16 combinaciones de bits diferentes que se pueden crear f√°cilmente para representar cada uno de los 10 d√≠gitos decimales que usamos habitualmente, con 6 s√≠mbolos de sobra. Este chip fue dise√±ado para calculadoras de bolsillo, con 4 bits bastaba. Poco despu√©s, le sigui√≥ el i4040 en la misma l√≠nea.</p>
<p>Luego llegaron los procesadores de 8 bits, que contaban con 2‚Å∏, es decir, 256 s√≠mbolos diferentes, suficientes para representar n√∫meros, letras may√∫sculas y min√∫sculas, puntuaci√≥n y a√∫n quedaban muchos s√≠mbolos de reserva. La codificaci√≥n EBCDIC de IBM usa 8 bits y la US-ASCII usa 7 bits, por lo que ambos encajan en 8 bits.</p>
<p>Intel hizo un primer intento con un procesador de 8 bits con un chip que llamaron i8008 destinado a una terminal ASCII inteligente, que no tuvo mucho √©xito fuera de ese √°mbito, seguido por el i8080 que domin√≥ el mundo de la microinform√°tica de 8 bits durante varios a√±os junto con sus derivados, como el Zilog Z80 que estaba en el coraz√≥n del Tandy / Radio Shack TRS-80 o el Sinclair, todos los cuales compitieron con la familia de procesadores 6502 populares en Amiga, Commodore y Apple II.</p>
<p>Fue en aquellos tiempos, cuando un peque√±o microprocesador de 8 bits apenas pod√≠a manejar una sola microcomputadora, que una empresa de Ann Arbor, Michigan, Sycor Inc., anunci√≥ un sistema capaz de admitir hasta 8 usuarios en una sola m√°quina: el Sycor 445. Sycor desapareci√≥ hace mucho tiempo, vendida a la canadiense Northern Telecom, que continu√≥ fabricando esos sistemas bajo su marca como NT 445, con colores ligeramente diferentes en la carcasa, y posteriormente desarroll√≥ el NT 585. Les perd√≠ la pista despu√©s de eso; Northern Telecom, luego rebautizada Nortel, eventualmente quebr√≥.</p>
<p>Creo que Sycor vend√≠a principalmente sus sistemas anteriores a trav√©s de otras marcas m√°s reconocidas en el mercado, al menos en el extranjero. Sus primeras m√°quinas llegaron a Argentina a trav√©s de la filial local de Olivetti de Italia, raz√≥n por la cual me involucr√© con ellos. Posteriormente, Olivetti quiso desarrollar sus propios sistemas en este rango y abandon√≥ los de Sycor <a href="/blog/2024/11/07/olivetti-de-5xx-sycor-de-3xx.html">antes de tener listo el propio</a>. Sin embargo, como se hab√≠an vendido muchas m√°quinas Sycor en Argentina, quienes ten√≠amos experiencia con esos sistemas nos pasamos a otras empresas que se encargaron del soporte t√©cnico de los sistemas instalados e incluso vendieron los nuevos directamente de Sycor y, posteriormente, de Northern Telecom.</p>
<p>La <em>445</em>, como la llam√°bamos, era una m√°quina maravillosa. El gabinete llegaba hasta la cintura, unos 40cm de ancho y un metro de profundidad. Su dise√±o simple y elegante encajaba en cualquier oficina, siendo silenciosa y sin requisitos de instalaci√≥n especiales como aire acondicionado. Pod√≠a manejar hasta ocho terminales, cada una a una distancia de hasta 600m, lo que permit√≠a atender no solo a las oficinas administrativas, sino tambi√©n a las terminales de la f√°brica o las del almac√©n. Varios <em>445</em> se pod√≠an interconectar entre s√≠ formando una red de √°rea local <em>LAN</em>, compartiendo recursos entre todas ellas.  Conoc√≠ un cliente que ten√≠a 5 unidades conectadas entre s√≠ con las terminales por toda la empresa y varias unidades de discos externos removibles de 300MB cada uno, un verdadero centro de c√≥mputos con s√≥lo 5 <em>445</em>.</p>
<p>Internamente, contaba con un microprocesador Intel i8080 con hasta 256kB de memoria y un disco duro de 10MB en un √∫nico plato de 14 pulgadas o 36cm de di√°metro. Se pod√≠a a√±adir mucho m√°s almacenamiento externo. Recordemos que eran finales de los 70 y las capacidades de memoria y disco estaban en esos rangos: kilobytes y megabytes, nada de <em>gigas</em> ni <em>teras</em>. Nadie pod√≠a imaginar semejante capacidad de almacenamiento en aquella √©poca.</p>
<p>El i8080 no era realmente un microprocesador de un solo chip, sino un conjunto de tres chips. Todos los dise√±os de Intel desde el i4004 hab√≠an sido multichip. La CPU necesitaba un par de chips de soporte, un generador de reloj y un controlador de bus. Tambi√©n requer√≠a fuentes de alimentaci√≥n de m√°s y menos 5 voltios y de m√°s 12 V. Sus sucesores, como el propio i8085 de Intel o el Z80, prescindieron de todo esto, lo que result√≥ en dise√±os mucho m√°s compactos.</p>
<h3 id="circuiter%C3%ADa-adicional" tabindex="-1">Circuiter√≠a adicional</h3>
<p>El i8080 pod√≠a gestionar hasta 2<sup>16</sup> , es decir, 64kB de memoria. Los ingenieros de Sycor hicieron un excelente trabajo al ampliar esta capacidad a 256kB mediante el mapeo de memoria mediante un circuito simple e incre√≠blemente elegante, creado con circuitos integrados de peque√±a escala (SSI). Cualquier combinaci√≥n de bloques de 2kB de esos 256kB de memoria principal pod√≠a mapearse en los 64kB del i8080. A medida que el sistema operativo cambiaba de tarea, se encargaba de asignar a cada tarea sus bloques de memoria correspondientes.</p>
<p>Todo ese circuito, y algunos m√°s que mencionar√© en breve, resid√≠an en una placa de circuito impreso (PCB) del tama√±o aproximado de un disquete de los de entonces, es decir, uno de 8&quot;, ya que los m√°s peque√±os de 5&quot; ¬º a√∫n no hab√≠an llegado. Ambos eran flexibles, a diferencia de los posteriores de 3,5&quot;, que eran r√≠gidos.</p>
<p>El <em>445</em> ten√≠a una placa base que recorr√≠a todo el chasis y que albergaba y conectaba a todas las otras. A diferencia de otros sistemas de bus, donde todas las ranuras de la placa base son pr√°cticamente iguales (todos los pines 1 est√°n conectados entre s√≠, al igual que los pines 2, y as√≠ sucesivamente, de modo que cualquier placa puede conectarse en cualquier lugar), cada ranura, o peque√±o conjunto de ellas, estaba dedicada a una funci√≥n espec√≠fica. Por lo tanto, hab√≠a dos ranuras reservadas para las CPUs, cuatro para las placas de memoria RAM, cuatro para las terminales, una para la placa controladora del disco interno, una para el cartucho de cinta magn√©tica, y as√≠ sucesivamente con todos los perif√©ricos. Estas eran las opciones b√°sicas del sistema. Otras placas pod√≠an gestionar unidades de disco externas, unidades de cinta de carrete abierto de media pulgada, redes, comunicaci√≥n remota y varios dispositivos externos m√°s.</p>
<figure>
<img title="Wire wrapped backplane picture by Retro-Computing Society of Rhode Island&hairsp;-&hairsp;Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=5094625" src="assets/img/512px-PDP-8I-backplane.jpg">
<figcaption>
Placa base de un PDP-8I con cableado enrollado o *wire-wrapped*
</figcaption>
</figure>
<p>La placa base solo ten√≠a las trazas de cobre para proveer alimentaci√≥n y tierra que eran comunes a todas las placas y serv√≠a de soporte a una serie de z√≥calos donde enchufar las placas funcionales y en cuyo reverso ten√≠a <a href="https://es.wikipedia.org/wiki/Wire-wrap">postes para enrollar cable</a>, que era la forma habitual de construir sistemas en aquella √©poca. Estos postes se conectaban entre s√≠ con innumerables cables, como se ve en la imagen superior. A medida que se dispon√≠a de m√°s perif√©ricos y se redise√±aban otros, algunas ranuras pod√≠an recablearse. Esto permit√≠a una gran flexibilidad y crecimiento, ya que el dise√±o del sistema pod√≠a modificarse con relativa facilidad, pero recablearlos era realmente peligroso, ya que cualquier error pod√≠a ser muy dif√≠cil de identificar en semejante mara√±a de cables. Un peque√±o descuido con el alicate pod√≠a llevar un par de d√≠as averiguar qu√© fallaba. Afortunadamente, esos cambios de dise√±o implicaban muy pocos cables que tuvieran que cortarse y reemplazarse. Nunca recable√°bamos una placa base en su totalidad. Aun as√≠, sol√≠amos hacerlo dos personas: una cortando y enrollando cables, la otra leyendo las instrucciones, supervisando a la primera y tildando las casillas en la hoja de trabajo.</p>
<p>Originalmente, el sistema se dise√±√≥ con dos CPU, ambas i8080. Una operar√≠a como CPU principal mientras la otra se encargar√≠a del manejo de todos los perif√©ricos. Si alguna vez sali√≥ de f√°brica un sistema con doble CPU no lo s√© pero al menos estoy seguro de que nunca lleg√≥ a Argentina. Pero, antes de explicar c√≥mo solucionaron esto, perm√≠tanme explicar c√≥mo afect√≥ esto al dise√±o de la placa base de la CPU.</p>
<p>La placa de la CPU, con su i8080 y sus circuitos auxiliares, y el mapeador de memoria recibieron algunas mejoras. Con dos CPU en el sistema, como se hab√≠a planeado originalmente, se habr√≠a producido un cuello de botella al intentar acceder a la memoria, ya que esta se compart√≠a entre ambas. Por lo tanto, a√±adieron dos funciones adicionales a la placa de la CPU. No estoy completamente seguro de mi descripci√≥n de las mismas, ya que me baso en recuerdos de hace varias d√©cadas y no conservo ninguna copia de los manuales, pero estaban ah√≠, aunque quiz√°s no exactamente como las describo.</p>
<h2 id="almacenamiento-en-memoria-cach%C3%A9" tabindex="-1">Almacenamiento en memoria cach√©</h2>
<p>Todas las lecturas de datos se realizaban en palabras de 16 bits. Aunque el i8080 era un procesador de 8 bits de ancho de palabra, se a√±adieron circuitos adicionales para que, al acceder a un byte, tambi√©n se leyera el siguiente. El byte solicitado pasaba directamente al chip de la CPU, y el siguiente se almacenaba en un simple <em>latch</em>, una memoria de un byte por as√≠ decirlo. No recuerdo c√≥mo se gestionaban las escrituras, supongo que iban directas de la CPU a la memoria sin ninguna optimizaci√≥n. Como la cantidad de lecturas es mucho mayor que de escrituras, se pueden realizar escrituras deficientes y aun as√≠ tener una ventaja optimizando solamente las lecturas.</p>
<p>Dado que la mayor√≠a de las operaciones de datos suelen implicar el acceso a m√∫ltiples bytes consecutivos de la memoria, como la lectura de caracteres consecutivos de una cadena, era l√≥gico tener la placa base cableada para 16 bits de datos y que la placa de la CPU leyera dos bytes a la vez. Muchos compiladores pueden configurarse para almacenar variables a partir de una ubicaci√≥n de memoria par de modo que el c√≥digo compilado quede optimizado para esta transferencia de datos de 16 bits.</p>
<p>Esto es importante porque, con dos CPU, no se desea que cada una espere constantemente a que la otra realice sus b√∫squedas de memoria. Por lo tanto, si cada CPU puede leer dos bytes en una sola operaci√≥n, le da tiempo a la otra para hacer lo mismo alternando turnos.</p>
<h2 id="precarga-de-instrucciones" tabindex="-1">Precarga de instrucciones</h2>
<p>El otro truco que usaron fue la precarga de instrucciones. Si se intenta optimizar la transferencia de datos a trav√©s de un bus compartido, la precarga de bloques de c√≥digos de instrucci√≥n es una excelente opci√≥n, debido a las caracter√≠sticas comunes de los programas cuando se ejecutan.</p>
<p>La mayor√≠a de los programas se componen de secuencias m√°s o menos largas de c√≥digos de instrucci√≥n almacenados en memoria consecutivamente. Los programas son como tramos m√°s o menos largo de caminos sin bifurcaciones. Las bifurcaciones son c√≥digos de instrucci√≥n que indican a la CPU que contin√∫e la ejecuci√≥n en otra ubicaci√≥n. Afortunadamente, no ocurren con tanta frecuencia; menos de 1 de cada 5 instrucciones es una bifurcaci√≥n. Y muchas bifurcaciones son condicionales; es decir, si la condici√≥n falla, el programa contin√∫a con la instrucci√≥n siguiente como si nada. Adem√°s, en un i8080, muchos c√≥digos de instrucci√≥n requieren dos y algunas hasta tres bytes, por lo que, estad√≠sticamente, si se lee un byte que contiene un c√≥digo de instrucci√≥n de la memoria, es probable que se deba leer el siguiente de la ubicaci√≥n inmediatamente posterior, y el siguiente, y as√≠ sucesivamente. De vez en cuando, se encontrar√° y se ejecutar√° una bifurcaci√≥n, lo que puede obligar a descartar lo precargado, pero no importa, la mayor√≠a de las veces, en promedio, 9 de cada 10, lo precargado se aprovecha.</p>
<p>Adem√°s, ning√∫n programa que funcione correctamente se modifica a s√≠ mismo, por lo que se puede asumir que la memoria donde reside el c√≥digo es de solo lectura. Uno de los problemas del almacenamiento en cach√© de datos es que lo que se acaba de almacenar podr√≠a ser modificado por otras CPU del sistema y la copia en cach√© podr√≠a dejar de reflejar el valor actual en la memoria. Esto no ocurre cuando el c√≥digo es inmutable. Por lo tanto, si se precargan varias instrucciones, se puede asumir con seguridad que son v√°lidas y lo seguir√°n siendo.</p>
<p>Afortunadamente, el chip i8080 ten√≠a un pin que indicaba si lo que estaba leyendo era un dato para procesar o un c√≥digo de instrucci√≥n para ejecutar, as√≠ se puede saber cu√°ndo lo que quiere leer es c√≥digo y, por ende, precargarlo.</p>
<h2 id="%C2%BFpor-qu%C3%A9-no-hubo-una-segunda-cpu%3F" tabindex="-1">¬øPor qu√© no hubo una segunda CPU?</h2>
<p>Aunque la placa base ten√≠a una ranura para una segunda tarjeta de CPU, no tengo constancia de que se vendiera ninguna gracias a que sali√≥ el i8085. Este era un derivado del i8080 original, pero m√°s adecuado como microcontrolador que como CPU principal. Un microcontrolador es lo que se utiliza para gestionar hardware externo, como unidades de disco o cinta, puertos de impresora paralelos o puertos de comunicaci√≥n serie, y otros dispositivos. Por lo tanto, en lugar de depender de una segunda placa de CPU con un i8080 para gestionar todas las entradas/salidas (E/S) y que los controladores fueran simples, Sycor decidi√≥ instalar un i8085 en cada placa controladora de E/S y dotar a cada una de ellas de inteligencia (al menos algunas de ellas).</p>
<p>Cuando se requer√≠a una operaci√≥n de E/S, el sistema operativo escrib√≠a lo que se denominaba un <em>Bloque de Control de Dispositivo</em> (DCB por sus iniciales en ingl√©s) en la memoria principal. El DCB conten√≠a informaci√≥n sobre qu√© hacer y d√≥nde ubicar los datos a intercambiar. A continuaci√≥n, le enviaba una se√±al al controlador de E/S avis√°ndole que ten√≠a este nuevo DCB esperando a ser procesado en tal o cual direcci√≥n y lo dejaba realizar su trabajo, mientras la CPU principal continuaba con otra cosa, posiblemente pasando a ejecutar otro programa o a atender a otro usuario. Una vez finalizada la operaci√≥n, el controlador de E/S informaba al sistema operativo de que la esta se hab√≠a completado, habiendo registrado los resultados en el DCB o donde este hubiera indicado.</p>
<p>De hecho, el DCB ten√≠a un campo que apuntaba al siguiente DCB para el mismo tipo de dispositivo. Por lo tanto, una vez que un controlador terminaba con un DCB, pod√≠a pasar directamente al siguiente DCB en la cadena sin distraer a la CPU principal. Asimismo, el sistema operativo no necesitaba esperar a que un controlador de E/S procesara un DCB para indicarle qu√© hacer a continuaci√≥n; simplemente encadenaba DCB con todas las solicitudes de E/S que necesitaba y dejaba que los controladores de E/S las procesaran a su propio ritmo.</p>
<h2 id="terminales" tabindex="-1">Terminales</h2>
<p>El sistema pod√≠a gestionar hasta ocho terminales con pantalla y teclado -en esa √©poca no hab√≠a <em>mouse</em> ni interfaz gr√°fica- cada una a una distancia de hasta 600 metros y lo hac√≠a de la forma m√°s ingeniosa. ¬øRecuerdan que mencion√© que la CPU ten√≠a un mapeador de memoria que pod√≠a asignar cualquier bloque de 2kB a los 64kB que el i8080 pod√≠a manejar? Uno de esos bloques de memoria de 2kB era la memoria de pantalla, una para cada terminal. Esta memoria no se encontraba junto a la memoria principal sino en cada placa controladora de terminal pues, mientras que la CPU principal acced√≠a a esta memoria ocasionalmente, el controlador de pantalla la utilizaba continuamente, por lo que era l√≥gico tenerla dentro del propio controlador.</p>
<p>En t√©rminos inform√°ticos, 2k significa en realidad 2048 bytes, no 2000 como cabr√≠a esperar del prefijo <em>kilo</em>, simplemente porque 2048 es un n√∫mero redondo en binario: es 2<sup>10</sup> o un 1 seguido de 10 ceros en binario. El controlador de pantalla utilizaba esta memoria para diversos fines. Con 25 l√≠neas de 80 caracteres cada una (24 de texto m√°s la l√≠nea de estado inferior), 2000 bytes se utilizaban para los caracteres que se mostraban en la pantalla de v√≠deo. Los 48 bytes restantes se utilizaban para diversos fines, como la posici√≥n del cursor, el estado de la tecla Bloq May√∫s o si se pulsaba la tecla May√∫s. El resto se reservaba para el b√∫fer del teclado, una cola de corta duraci√≥n para almacenar las pulsaciones de teclas hasta que el programa en ejecuci√≥n pudiera procesarlas.</p>
<p>Lo m√°s ingenioso era que la terminal era un monitor de televisi√≥n anal√≥gico completamente tonto. Un par de cables simplemente transmit√≠an la se√±al de televisi√≥n anal√≥gica simple, una l√≠nea de barrido a la vez, con su correspondiente pulso de sincronizaci√≥n horizontal (HSync) y el pulso de sincronizaci√≥n vertical (VSync) como un aparato de TV anal√≥gico cualquiera. Incluso ten√≠a peor resoluci√≥n que una se√±al de televisi√≥n convencional y no mostraba tonos de gris; era simplemente p√≠xel encendido o apagado. Por eso las terminales de pantalla pod√≠an estar tan lejos: eran simples monitores de televisi√≥n.</p>
<p>La se√±al de TV se generaba mediante un barrido continuo por los 2kB de la memoria de la pantalla convirtiendo cada car√°cter en el patr√≥n de p√≠xeles a mostrar al pasar por una memoria ROM con la √∫nica fuente disponible, varias veces por segundo. Por eso, la memoria de la pantalla se encontraba en la tarjeta controladora del terminal y no formaba parte de la memoria principal. La CPU principal solo necesitaba acceder a esta memoria cuando algo cambiaba en la pantalla, lo cual era relativamente poco frecuente. El controlador de v√≠deo lo hac√≠a continuamente.</p>
<p>El truco estaba en el teclado. Los teclados suelen tener una matriz de cables con varias columnas y filas, con teclas en las intersecciones. El controlador del teclado activaba, digamos, una columna y le√≠a todas las filas una a una para esa columna, luego activaba otra columna y volv√≠a a leer todas las filas y as√≠ repetidamente.  Al pulsar una tecla, se conectaba un cable de columna con un cable de fila; de esta manera, cuando el cable de columna estaba activo, el cable de fila correspondiente tambi√©n lo estaba.</p>
<p>Este teclado ten√≠a un contador simple que se reiniciaba con la se√±al VSync del monitor y se incrementaba en uno por cada se√±al HSync. Cada valor del conteo correspond√≠a a una columna a activar y una fila a leer. La placa controladora de pantalla ten√≠a el mismo tipo de contador, contando en paralelo al del terminal, utilizando las mismas se√±ales VSync y HSync. El teclado enviaba la se√±al de tecla pulsada al controlador, el cual, al llevar el mismo conteo en sincron√≠a con el teclado, sab√≠a qu√© coordenada de la matriz estaba cortocircuitada y a qu√© car√°cter correspond√≠a.</p>
<p>Este circuito tan simple permit√≠a que las terminales estuvieran a una distancia de hasta 600 metros y a√∫n as√≠ responder como terminales locales, lo que era toda una haza√±a en aquellos d√≠as.</p>
<h2 id="cp%2Fm-y-mp%2Fm" tabindex="-1">CP/M y MP/M</h2>
<p>Aprend√≠ muchos de estos detalles gracias a un proyecto personal. El <em>445</em> ejecutaba su propio sistema operativo propietario, como la mayor√≠a de las computadoras de la √©poca. Contaba con un compilador COBOL, un int√©rprete BASIC muy primitivo (experimental) y un lenguaje propietario para describir y validar las pantallas de entrada de datos. Esto me parec√≠a insuficiente. CP/M era el sistema operativo m√°s popular en aquel entonces para computadoras personales de 8 bits y contaba con todo tipo de software de aplicaci√≥n, como procesadores de texto, hojas de c√°lculo y compiladores e int√©rpretes para muchos lenguajes de programaci√≥n adem√°s de COBOL. Adem√°s, pod√≠a personalizarse para funcionar en cualquier m√°quina con un microprocesador compatible con i8080.</p>
<p>Como √©ramos el √∫nico distribuidor de Sycor del pa√≠s, siempre ten√≠amos algunos <em>445</em>, ya sea para desarrollar software para clientes o en el taller, algunos en funcionamiento, otros como repuestos o bancos de pruebas. As√≠ que, si alguno estaba disponible, pod√≠a jugar con √©l.</p>
<p>Para personalizar CP/M, era necesario escribir, generalmente en ensamblador para i8080, los controladores para la terminal y la unidad de disco de la m√°quina. Como en el <em>445</em> el controlador de disco era inteligente, solo ten√≠a que escribir en memoria los DCB que mencion√© antes y el controlador de disco se encargar√≠a de todo. Esto me evit√≥ la molestia de gestionar las complejidades del hardware del disco. ¬°Y funcion√≥! Pude cargar CP/M en el disco de mi m√°quina y arrancarla directamente en CP/M. Pero ese era solo el primer paso.</p>
<p>CP/M era un sistema operativo para un solo usuario y solo pod√≠a gestionar los 64kB de memoria b√°sicos a los que el i8080 pod√≠a acceder por s√≠ solo. Ten√≠a una m√°quina capaz de gestionar hasta 8 usuarios y 256kB de memoria. Por eso mi objetivo era el MP/M, que era la versi√≥n multiusuario de CP/M, que tambi√©n se pod√≠a personalizar para cualquier m√°quina compatible con CP/M y que tuviera mapeo de memoria para poder darle a cada usuario su buena cuota de memoria.</p>
<p>Para hacer esto, era necesario tener una m√°quina que ejecutara CP/M, que yo ya ten√≠a, y luego agregar el c√≥digo para manejar el mapeador de memoria para as√≠ asignar cualquier bloque de 2kB de esos 256kB de memoria principal m√°s los 2kB de cada pantalla a los 64kB dedicados para cada usuario.</p>
<p>Desafortunadamente, nunca termin√© esa parte y nunca consegu√≠ que el <em>445</em> funcionara con MP/M. Surgi√≥ un gran proyecto y todos los recursos de la empresa, tanto de la m√°quina con la que estaba trabajando como de mis compa√±eros y yo, tuvimos que trabajar en √©l. Para cuando termin√≥ el proyecto, me trasladaron a otra √°rea y rara vez volv√≠ a tener un <em>445</em> para mi. Y, de todas formas, hab√≠a sido una apuesta perdida de antemano, ya que, para entonces, el IBM PC se estaba volviendo popular y una m√°quina MP/M multiusuario de 8 bits ya no era atractiva. Adem√°s, estaba trabajando con una familia mucho m√°s grande de minicomputadoras y mainframes, y el <em>445</em> me parec√≠a un poco peque√±o.</p>
<h2 id="conclusi%C3%B3n" tabindex="-1">Conclusi√≥n</h2>
<p>La mayor√≠a de los circuitos adicionales que describ√≠ aqu√≠ que rodean al i8080 en la placa base de la CPU no deber√≠an ser nuevos para los dise√±adores de CPUs. De hecho, el sistema con el que trabaj√© posteriormente ni siquiera usaba un microprocesador de un solo chip como procesador principal; estaba compuesto por circuitos SSI (Small Scale Integration) o MSI (Medium Scale Integration) simples en una placa de circuito impreso de casi medio metro de lado. Pero el <em>445</em> fue el primer sistema del que dispuse los manuales completos y me encant√≥ descubrir c√≥mo consegu√≠an sacarle tanto partido.</p>
<p>Hoy en d√≠a, todo est√° oculto en los potentes chips de CPU que dise√±an y producen los principales fabricantes. M√∫ltiples procesadores en un solo chip (<em>multi-core</em> le dicen), con abundante memoria integrada para cach√©, colas de instrucciones, predicci√≥n de saltos y muchas m√°s funciones que ni siquiera conocemos. En aquel entonces, todo estaba a la vista de cualquiera. El propio funcionamiento interno del i8080 era comprensible. Ahora, los chips m√°s nuevos son casi magia negra.</p>
<p>En cuanto a portar MP/M, tambi√©n habr√≠a tenido otro gran problema. Incluso si hubiera logrado que funcionara, habr√≠a sido invendible. El software de c√≥digo abierto (OSS) llegar√≠a mucho despu√©s. Hoy en d√≠a, nadie se lo piensa dos veces antes de usar Linux, ni las innumerables aplicaciones OSS que se ejecutan en √©l, en Windows o en Mac. No era as√≠ en aquel entonces; los gerentes de sistemas quer√≠an software con soporte completo de sus proveedores. Mi versi√≥n de MP/M habr√≠a sido ignorada.</p>
<p>Ni siquiera ten√≠a forma de intercambiar informaci√≥n f√°cilmente con Sycor para <em>venderles</em> (conceptualmente) mi idea. De hecho, es muy probable que algunos de sus ingenieros estuvieran considerando la misma idea, pero yo no ten√≠a forma de saberlo. En aquella √©poca no hab√≠a correo electr√≥nico, ni Internet, ni siquiera tablones de anuncios electr√≥nicos. Solo hab√≠a llamadas telef√≥nicas, cartas, telex o fax, y yo estaba demasiado lejos de ellos.</p>
<p>Mala suerte.</p>

          </div>
          <footer class="post-footer"><div class="next-prev-links">
  
  <a class="next-link" title="Siguiente"
href="2025/12/05/la-desaparicion-del-papel.html"
>La desaparici√≥n del papel 
<div class="triangle-right"></div>
</a>

</div> </footer>
          <a class="u-url" href="/blog/2026/01/18/ocho-usuarios-trabajando-desde-un-unico-procesador-i8080.html" hidden></a>
        </article>
      </div>
    </main>
    <footer class="site-footer h-card">
      <data class="u-url" href="/blog"></data>

      <div class="wrapper">
        <h2 class="footer-heading">Comentarios</h2>

        <div class="footer-col-wrapper">
          <div class="footer-col footer-col-1">
            <ul class="contact-list">
              <li class="p-name">Comentarios</li>
              <li>
                <a class="u-email" href="mailto:satyam@satyam.com.ar"
                  >satyam@satyam.com.ar</a
                >
              </li>
            </ul>
          </div>

          <div class="footer-col footer-col-2">
            <ul class="social-media-list"></ul>
          </div>

          <div class="footer-col footer-col-3">
            <p>Comentarios, viajes, ideas e historias</p>
          </div>
        </div>
      </div>
    </footer>
    
  <script src="assets/js/highlight.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>

  </body>
</html>
