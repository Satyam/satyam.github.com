<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <title>JSON Schema and DataTypes</title>
		<style>
			td , th , table {
				border: thin solid silver;
			}
			td , th {
				padding: 5px;
			}
			.yui3-formfieldplugin-label {
				float: left;
				margin: 2px 5px;
			}
		</style>


    </head>
    <body class="yui3-skin-sam yui-skin-sam">

		
		<div id="test"></div>
		<hr/>
		<form id="form"></form>

		<script src="http://yui.yahooapis.com/3.4.0/build/yui/yui-min.js"></script>

		<script>
			YUI({
				// debug:true,
				// useBrowserConsole:true,
				// filter: 'debug',
				gallery: 'gallery-2011.09.14-20-40'
			}).use(
				'datatype','yui-base','oop','node','gallery-makenode','event-valuechange','plugin','widget','widget-child',
				function(Y) {
					"use strict";
					
					var Lang = Y.Lang,
						PARSER = 'parser',
						FORMATTER = 'formatter',
						UI = 'UI',
						SERVER = 'server',
						SEPARATOR = '|';
					
					/*
						I improved on the original DataTypes by providing methods to help manipulate the data.
						Now, the data is stored under a private variable _types and the methods help you reach it.
						
						Normally, the data would be composed from bits and pieces loaded according to locale and other environment circumstances.
						An entry can be reached via the use() method passing it the schema entry and which side, UI or server you want.
						
						The use() method reads from the _types and merges the information from all levels so that if an entry exists 
						for a particular type and format, it will use that, but it will fall back to the entry for the generic type 
						(without format) if there is no entry for format.  If there is not entry at all, it will default to a basic do-nothing
						set.  Since assembling this datatype entry takes time, the results are cached so that in later requests, the 
						cached value is read.  The cache is emptied if new data is added to the types (not implemented yet).
						
						Method get() takes an schema entry, the side UI or server and what is it that you want.  It returns the value for that
						property.  
						
						Method invoke() takes the schema entry, the side, what function you want to call (usually 'formatter', 'parser',
						'validator' and so on) and any extra arguments the function might need.  It will return the result of that function.
						
						Functions to be called by invoke will receive any values
						the caller to invoke might have passed and a reference to the schema entry, 
						so it could read any extra information stored there.  
						
						The number of arguments a function receives might vary.  It is usually one, the value to be formatted,
						parsed or validated, but other functions might need more.  Thus schemaEntry might not always be the second
						argument, it all depends on how many other values have been passed.  Originally, to avoid this issue
						of getting the schema entry bumped to different positions according to how many values are there,
						I placed it in the first position and then the values, but since the schema entry is rarely used,
						it was really annoying to have it declared just as a placeholder and never used, so I put the
						values firts.
						
						The context for the invoked function will be set to the data type entry.
						This entry is a composition of the specific entries and all the fallback values.  
						Thus, if there is a property formatMask for a particular type, lets say, type:number, format: currency,
						it will have that, if it doesn't, the one for type:number will be available and, since the property
						has no default, if that isn't available, formatMask would be undefined, otherwise you would get that default.
						
						This means that the entries for type/format do not need to repeat information that can be provided at
						the type level.

					*/
					var DTs = {
					
						get: function (schemaEntry, side, what) {
							return DTs.use(schemaEntry, side)[what];
						},
						invoke: function (schemaEntry, side, what) {
							var branch = DTs.use(schemaEntry, side),
								args = Y.Array(arguments).slice(3);
							args.push(schemaEntry);
							if (branch[what]) {
								return branch[what].apply(branch, args);
							}
						},
						use: function (schemaEntry, side) {
							/* In order for Y.cached to work, the method needs to receive string arguments
							   or objects whose toString() method produces unique strings so that cached
							   can used them as keys.  Since schemaEntry has no toString() method,
							   the fallback is Object.toString() which produces [object: object] or
							   something like that, the very same key for all entries so it would always
							   return the same value.  That's why I had to expand it.
							*/
							return this._use(schemaEntry.type, schemaEntry.format, side);
						},
						
						add: function (type, format, side, entry, value) {
							var self = this, item, next;
							if (value) {
								item = DTs._types;
								if (format) {
									type = type + SEPARATOR + format;
								}
								next = item[type];
								if (!next) {
									next = item[type] = {};
								}
								item = next;
								next = item[side];
								if (!next) {
									next = item[side] = {};
								}
								item = next;
								next = item[entry];
								if (!next) {
									next = item[entry] = {};
								}
								item = next;
								item = value;
								DTs._cache = {};
								return;
							} 
							if (Lang.isObject(entry)) {
								Y.each(entry, function (values, entry) {
									self.add(type, format, side, entry, values);
								});
								return;
							}
							if (Lang.isObject(side)) {
								Y.each(side, function (values, side) {
									self.add(type, format, side, values);
								});
								return;
							}
									
							if (Lang.isObject(format)) {
								Y.each(format, function (values, format) {
									self.add(type, format, values);
								});
								return;
							}
							if (Lang.isObject(type)) {
								Y.each(type, function (values, type) {
									self.add(type, values);
								});
								return;
							}
							Y.log('If it ever reaches this far, it is an error','error','datatypes');
						},

						_cache: {},
								
						_types: {
							'string|date-time': {
								UI: {
									formatMask: '%d/%b/%Y %T',
									formatter: function (value) {
										return Y.DataType.Date.format(value, {format:this.formatMask});
									},
									parser: function (value) {
										return Date.parse(value);
									}
								},
								server: {
									// YYYY-MM-DDThh:mm:ssZ
									formatMask:'%FT%T%Z',
									formatter: function (value) {
										return Y.DataType.Date.format(value, {format: this.formatMask});
									},
									// this one would fail in so many ways that it's worthless, but for an example, it will do.
									parser: function (value) {
										var tmz = value.substr(-1),  // I am doing nothing with the timezone, though I should :P
											a = value.substr(0,value.length -1);
										a = a.split('T');
										a[0] = a[0].split('-');
										a[1] = a[1].split(':');
										return new Date(a[0][0],a[0][1] -1 ,a[0][2],a[1][0],a[1][1],a[1][2]);
									}
								}
							},
							'integer': {
								UI: {
									formatter: function (value) {
										return value.toString();
									},
									parser: function (value) {
										return parseInt(value, 10);
									}
								},
								server: {
									formatter: function (value) {
										return value.toString();
									},
									parser: function (value) {
										return parseInt(value, 10);
									}
								}
							},
							'number': {
								UI: {
									formatter: function (value) {
										return value.toString();
									},
									parser: function (value) {
										return parseFloat(value);
									}
								},
								server: {
									formatter: function (value) {
										return value.toString();
									},
									parser: function (value) {
										return parseFloat(value);
									}
								}
							},
							'number|currency': {
								UI: {
									formatter: function (value) {
										return Y.DataType.Number.format(value, {
											suffix:'€',
											decimalPlaces:2,
											decimalSeparator: ',',
											thousandsSeparator:'.'
										});
									},
									parser: function (value) {
										return parseFloat(value.replace(/[€.]/g,'').replace(',','.'));
									}
								},
								server: {
									formatter: function (value) {
										return value.toString();
									},
									parser: function (value) {
										return parseFloat(value);
									}
								}
							}
						}
					};	
					
					// I had to put this method here because the last argument, DTs._cache
					// gives an error if defined within DTs because DTs itself is not defined
					// at that point.
					DTs._use = Y.cached(function (type, format, side) {
						var noop = function (value) {
								return value;
							},
							retNull = function () {
								return null;
							},
							t = DTs._types[type],
							f = format?DTs._types[type + SEPARATOR + format]:{};
						return Y.merge(
							{
								formatter: noop,
								parser: noop
							},
							(side === UI? {validator: retNull}:{}),
							(t?t[side]:{}),
							(f[side] || {})
						);
					}, DTs._cache);
					Y.DataTypes = DTs;
					
					
					/* This is the schema I am going to use which describes the data below.
					*/
					var transactionSchema = {
						"name":"Transaction",
						"properties": {
							"id": {
								"type":"number",
								"description":"Transaction ID",
								"required":true
							},
							"descr": {
								"type":"string",
								"description":"Description"
							},
							"date": {
								"type":"string",
								"format":"date-time",
								"description":"transaction date",
								"title":"Date"
							},
							"amount":{
								"type":"number",
								"format":"currency",
								"description":"Amount",
								"title":"Amount"
							}
						}
					};
					
					// And this is the data, supposedly just read from the server and JSON-parsed.
					// The date, for example, remains as a string since it has not been processed according to the schema.
					var recordSet = [
						{id:12345,descr:"first transaction",date:"1969-07-20T20:17:39Z",amount:123123.45},
						{id:67890,descr:"last transaction",date:"1972-12-07T02:55:03R",amount:678678.90}
					];
					
					/*
						This function reads the data received from the server (above),
						processes it according to the given schema
						and returns an array with the values in their native JavaScript types.
						In this case, the only one actually changed in any way is the date,
						however, should the id or amount came as strings, they would have been converted
						to actual numbers
					*/
					var readFromServer = function(recordSet, schema) {
						var output = [], outRecord;
						Y.each(recordSet, function (inRecord) {
							outRecord = {};
							Y.each(schema.properties, function (fieldDef, fieldName) {
								outRecord[fieldName] = Y.DataTypes.invoke(fieldDef,SERVER,PARSER,inRecord[fieldName]);
							});
							output.push(outRecord);
						});
						return output;
					};
					
					/*
						Creates the HTML for a table.
						It reads the header cells from the schema taking either the title or description properties and
						if none is present, the field name itself.
						Then it goes and reads the records and formats them according to their type/format.
					*/
					
					var makeTable = function (recordSet, schema) {
						var table = [], tr = [], value;
						Y.each(schema.properties, function (fieldDef, fieldName) {
							tr.push('<th>' + (fieldDef.title || fieldDef.description || fieldName) + '<\/th>');
						});
						table.push('<tr>' + tr.join('\n') + '<\/tr>');
						Y.each(recordSet, function (record) {
							tr = [];
							Y.each(schema.properties, function (fieldDef, fieldName) {
								value = record[fieldName];
								value = Y.DataTypes.invoke(fieldDef, UI, FORMATTER, value);
								tr.push('<td>' + value + '<\/td>');
							});
							table.push('<tr>' + tr.join('\n') + '<\/tr>');
						});
						return '<table>' + table.join('\n') + '<\/table>';
					};
					
					/* 
						Finally, this inserts into a <div> the result of processing via makeTable what was read
						and processed via readFromServer, both using the same schema
					*/
					var internal = readFromServer(recordSet, transactionSchema);
					// console.log(internal);
					Y.one('#test').setContent(makeTable(internal, transactionSchema));
					
					var CBX = 'contentBox',
						BBX = 'boundingBox',
						VALUE = 'value',
						TITLE = 'title',
						LABEL = 'label',
						INPUT = 'input',
						ERR_MSG = 'errorMsg',
						VALIDATOR = 'validator',
						SCHEMA = 'schema';
						
					/*
						This is the base for a cell editor, basically, it uses a plain <input> box.
						See methods _uiSetValue, _afterInputValueChange and _afterInputBlur
						They all use the schema configuration attribute to pick the formatter, parser and validator
						from Y.DataTypes.
					*/
						
					var	BaseCellEditor = Y.Base.create(
						'base-cell-editor',
						Y.Widget,
						[Y.WidgetChild, Y.MakeNode],
						{
							renderUI: function () {
								this.get(CBX).append(this._makeNode());
								this._locateNodes();
							},
							bindUI: function () {
								// interim solution because as of 3.4.0, valueChange cannot be listened to by delegation
								this._eventHandles.push(this._inputNode.after('valueChange', this._afterInputValueChange, this));
							},
							_uiSetValue: function (value, src) {
								if (src === UI) {
									return;
								}
								this._inputNode.set(VALUE, DTs.invoke(this.get(SCHEMA), UI, FORMATTER, value));
							},
							_uiSetLabel: function (value) {
								this._inputNode.set(TITLE, value);
							},
							_uiSetErrorMsg: function (value) {
								this._inputNode.set(TITLE, value || this.get(LABEL));
							},
							_afterInputValueChange: function (ev) {
								this.set(VALUE, DTs.invoke(this.get(SCHEMA), UI, PARSER, ev.target.get(VALUE)), {src: UI});
							},
							_afterInputBlur: function (value)  {
								this.set(ERR_MSG, DTs.invoke(this.get(SCHEMA), UI, VALIDATOR, value));
							}								
						},
						{
							ATTRS: {
								value: {
								},
								label: {
								},
								errorMsg: {
								},
								schema: {
								}
							},
							_TEMPLATE: '<input class="{c input}" title="{@ label}" />',
							_CLASS_NAMES:[INPUT],
							_ATTRS_2_UI: {
								SYNC: [VALUE],
								BIND: [LABEL, ERR_MSG, VALUE]
							},
							_EVENTS: {
								// Unfortunately, valueChange is a synthetic event and cannot be hooked via _EVENTS
								// input: 'valueChange'
								input: 'blur'
							}
						}
					);
					
					/*
						This is the plugin that adds a label in between the bounding box and the content box
						and captures the _uiSetLabel method of the host to display it on the label.
						
						A similar plugin should be available to turn the base cell editor into a popup
						that could be overlayed anywhere.
					*/
					
					var FormFieldPlugin = Y.Base.create(
						'FormFieldPlugin',
						Y.Plugin.Base,
						[],
						{
							initializer: function () {
								this.afterHostEvent('render',this._afterHostRender);
								this.beforeHostMethod('_uiSetLabel', this._uiSetLabel);
								
							},
							_uiSetLabel: function(value) {
								this._labelNode.setContent(value);
								return new Y.Do.Prevent();
							},
							_afterHostRender: function () {
								var host = this.get('host'),
									bbx = host.get(BBX);
								this._labelNode = Y.Node.create('<label class="yui3-formfieldplugin-label"><\/label>');
								bbx.insert(this._labelNode,0);
								this._labelNode.setContent(host.get(LABEL));
							}
							
						},
						{
							NS:'FieldPlugin'							
						}
					);
					
					/*
						Here I create the cell editor plugged to have the label as a regular form field.
						The value is taken from the record parsed using the schema and the field
						holds a reference to the corresponding field in the schema.
					*/
					var inputField = new BaseCellEditor({
						label:'Date Field',
						value: internal[0].date,
						schema: transactionSchema.properties.date,
						plugins : [FormFieldPlugin]
						
					}).render('#form');
				
				}
			);
								

		</script>
        
    </body>
</html>
