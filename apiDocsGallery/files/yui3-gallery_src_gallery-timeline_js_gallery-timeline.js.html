<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>yui3-gallery&#x2F;src&#x2F;gallery-timeline&#x2F;js&#x2F;gallery-timeline.js - Satyam&#x27;s Gallery Modules</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="Satyam&#x27;s Gallery Modules"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Accordion.html">Accordion</a></li>
            
                <li><a href="..&#x2F;classes/AccordionPanel.html">AccordionPanel</a></li>
            
                <li><a href="..&#x2F;classes/Button.html">Button</a></li>
            
                <li><a href="..&#x2F;classes/ButtonGroup.html">ButtonGroup</a></li>
            
                <li><a href="..&#x2F;classes/ButtonPlugin.html">ButtonPlugin</a></li>
            
                <li><a href="..&#x2F;classes/ButtonSeparator.html">ButtonSeparator</a></li>
            
                <li><a href="..&#x2F;classes/ButtonToggle.html">ButtonToggle</a></li>
            
                <li><a href="..&#x2F;classes/FlyweightTreeManager.html">FlyweightTreeManager</a></li>
            
                <li><a href="..&#x2F;classes/FlyweightTreeNode.html">FlyweightTreeNode</a></li>
            
                <li><a href="..&#x2F;classes/FWTreeNode.html">FWTreeNode</a></li>
            
                <li><a href="..&#x2F;classes/FWTreeView.html">FWTreeView</a></li>
            
                <li><a href="..&#x2F;classes/GalleryModel.html">GalleryModel</a></li>
            
                <li><a href="..&#x2F;classes/GalleryModelChronologicalUndo.html">GalleryModelChronologicalUndo</a></li>
            
                <li><a href="..&#x2F;classes/GalleryModelMultiRecord.html">GalleryModelMultiRecord</a></li>
            
                <li><a href="..&#x2F;classes/GalleryModelPrimaryKeyIndex.html">GalleryModelPrimaryKeyIndex</a></li>
            
                <li><a href="..&#x2F;classes/GalleryModelSimpleUndo.html">GalleryModelSimpleUndo</a></li>
            
                <li><a href="..&#x2F;classes/GalleryModelSortedMultiRecord.html">GalleryModelSortedMultiRecord</a></li>
            
                <li><a href="..&#x2F;classes/IButton.html">IButton</a></li>
            
                <li><a href="..&#x2F;classes/MakeNode.html">MakeNode</a></li>
            
                <li><a href="..&#x2F;classes/Node.html">Node</a></li>
            
                <li><a href="..&#x2F;classes/Spinner.html">Spinner</a></li>
            
                <li><a href="..&#x2F;classes/StdMod.html">StdMod</a></li>
            
                <li><a href="..&#x2F;classes/TimeSpinner.html">TimeSpinner</a></li>
            
                <li><a href="..&#x2F;classes/Y.Timeline.html">Y.Timeline</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/gallery-button-plugin.html">gallery-button-plugin</a></li>
            
                <li><a href="..&#x2F;modules/gallery-flyweight-tree.html">gallery-flyweight-tree</a></li>
            
                <li><a href="..&#x2F;modules/gallery-fwt-treeview.html">gallery-fwt-treeview</a></li>
            
                <li><a href="..&#x2F;modules/gallery-makenode.html">gallery-makenode</a></li>
            
                <li><a href="..&#x2F;modules/gallery-md-accordion.html">gallery-md-accordion</a></li>
            
                <li><a href="..&#x2F;modules/gallery-md-button.html">gallery-md-button</a></li>
            
                <li><a href="..&#x2F;modules/gallery-md-button-group.html">gallery-md-button-group</a></li>
            
                <li><a href="..&#x2F;modules/gallery-md-ibutton.html">gallery-md-ibutton</a></li>
            
                <li><a href="..&#x2F;modules/gallery-md-model.html">gallery-md-model</a></li>
            
                <li><a href="..&#x2F;modules/gallery-md-spinner.html">gallery-md-spinner</a></li>
            
                <li><a href="..&#x2F;modules/gallery-md-timespinner.html">gallery-md-timespinner</a></li>
            
                <li><a href="..&#x2F;modules/gallery-stdmod.html">gallery-stdmod</a></li>
            
                <li><a href="..&#x2F;modules/timeline.html">timeline</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: yui3-gallery&#x2F;src&#x2F;gallery-timeline&#x2F;js&#x2F;gallery-timeline.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*global YUI*&#x2F;
&#x2F;**
 * Shows in the browser timeline files produced by the program from &lt;a href=&quot;http:&#x2F;&#x2F;thetimelineproj.sourceforge.net&#x2F;&quot;&gt;The Timeline Project&lt;&#x2F;a&gt;.
 * @module timeline
 *&#x2F;
&#x2F;**
 * Displays within a given container a timeline file from the given URL
 * @class Y.Timeline
 * @extends Y.Base
 * @constructor
 * @param config {Object} configuration options
 *&#x2F;

&quot;use strict&quot;;

var Lang = Y.Lang,
	REGION = &#x27;region&#x27;,
	START = &#x27;start&#x27;,
	END = &#x27;end&#x27;,
	LEFT = &#x27;left&#x27;,
	URL = &#x27;url&#x27;,
	CONTAINER = &#x27;container&#x27;,
	LOADED = &#x27;loaded&#x27;,
	CHANGE = &#x27;Change&#x27;,
	EVENT = &#x27;event&#x27;,
	CATEGORIES = &#x27;categories&#x27;,
	TOP = &#x27;top&#x27;,
	CENTER = &#x27;center&#x27;,
	RIGHT = &#x27;right&#x27;,
	PX = &#x27;px&#x27;,
	STRINGS = &#x27;strings&#x27;,
	TIMELINE = &#x27;timeline&#x27;,
	SHOW_DESCR = &#x27;showDescr&#x27;,
	cName = function() {
		return Y.ClassNameManager.getClassName.apply(this, [TIMELINE].concat(Y.Array(arguments)));
	},
	BLOCK_TEMPLATE = Y.Node.create(&#x27;&lt;div class=&quot;&#x27; + cName(&#x27;bar&#x27;) + &#x27;&quot; &#x2F;&gt;&#x27;),
	GRID_TEMPLATE = Y.Node.create(&#x27;&lt;div class=&quot;&#x27; + cName(&#x27;grid&#x27;) + &#x27;&quot;&#x2F;&gt;&#x27;),
	POINTER_TEMPLATE = Y.Node.create(&#x27;&lt;div class=&quot;&#x27; + cName(&#x27;pointer&#x27;) + &#x27;&quot; &#x2F;&gt;&#x27;),
	CATEGORIES_TEMPLATE = &#x27;&lt;div class=&quot;&#x27; + cName(&#x27;cats&#x27;) + &#x27;&quot;&gt;{categories}&lt;p class=&quot;&#x27; + cName(&#x27;noCat&#x27;) + &#x27;&quot;&gt;{noCategory}&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&#x27;;

Y.Timeline = Y.Base.create(
	TIMELINE,
	Y.Base,
	[],
	{
		&#x2F;**
		 * Stores the events to display.It contains the following properties, those starting with underscore are used internally:&lt;ul&gt;
		 * &lt;li&gt;&lt;b&gt;start&lt;&#x2F;b&gt;: {timestamp} start time in milliseconds&lt;&#x2F;li&gt;
		 * &lt;li&gt;&lt;b&gt;end&lt;&#x2F;b&gt;: {timestamp} end time in milliseconds&lt;&#x2F;li&gt;
		 * &lt;li&gt;&lt;b&gt;text&lt;&#x2F;b&gt;: {string} text to be shown on the bar&lt;&#x2F;li&gt;
		 * &lt;li&gt;&lt;b&gt;fuzzy&lt;&#x2F;b&gt;: {Boolean} the start and end days are uncertain &lt;&#x2F;li&gt;
		 * &lt;li&gt;&lt;b&gt;locked&lt;&#x2F;b&gt;: {Boolean} the event cannot be edited (not relevant for this viewer &lt;&#x2F;li&gt;
		 * &lt;li&gt;&lt;b&gt;endsToday&lt;&#x2F;b&gt;: {Boolean} the end day is today&lt;&#x2F;li&gt;
		 * &lt;li&gt;&lt;b&gt;description&lt;&#x2F;b&gt;: {string} extended description&lt;&#x2F;li&gt;
		 * &lt;li&gt;&lt;b&gt;icon&lt;&#x2F;b&gt;: {string} Base64-encoded image to go along the extended description&lt;&#x2F;li&gt;
		 * &lt;li&gt;&lt;b&gt;category&lt;&#x2F;b&gt;: {string} the category this event belongs to&lt;&#x2F;li&gt;
		 * &lt;li&gt;&lt;b&gt;_bar&lt;&#x2F;b&gt;: {Y.Node} reference to the Node for the bar representing this event&lt;&#x2F;li&gt;
		 * &lt;li&gt;&lt;b&gt;_pointer&lt;&#x2F;b&gt;: {Y.Node} for point events, reference to the Node for the date pointer&lt;&#x2F;li&gt;
		 * &lt;li&gt;&lt;b&gt;_isPoint&lt;&#x2F;b&gt;: {Boolean} signals that the event is a point event or a range event
		 *      that has become too narrow to be displayed as a range&lt;&#x2F;li&gt;
		 * &lt;&#x2F;ul&gt;
		 * @property _events
		 * @type Object []
		 * @default null
		 *&#x2F;
		_events: null,
		&#x2F;**
		 * Display mode for the bars, to help calculate its location and handle crowding.
		 * Can be standard (0), , compact (1) or overlappying (2)
		 * @property _mode
		 * @type {integer}
		 * @default 0
		 *&#x2F;
		_mode: 0,
		&#x2F;**
		 * Sets up listeners to respond to setting the URL,the CONTAINER or to the arrival of the timeline file.
		 * @method initializer
		 * @param cfg {Object} configuration attributes
		 * @protected
		 *&#x2F;
		initializer: function (cfg) {
			this._events = [];
			this.set(STRINGS, Y.Intl.get(&#x27;gallery-&#x27; + TIMELINE));
			this.after(URL + CHANGE, this._load);
			this.after(CONTAINER + CHANGE, this._render);
			this.after(LOADED + CHANGE, this._render);
			if (cfg &amp;&amp; cfg[URL]) {
				this._load();
			}
			if (cfg &amp;&amp; cfg[CONTAINER]) {
				this._render();
			}
			this.publish(SHOW_DESCR, {
				defaultFn: this._defShowDescr
			});
		},
		&#x2F;**
		 * Returns the boolean value of a given tag in an XML document
		 * @method _readBoolean
		 * @param xml {XMLDocument} The XML document or fragment to parse
		 * @param tag {String} The tag for the value sought
		 * @return {Boolean} the value read or null if not found
		 * @private
		 *&#x2F;
		_readBoolean: function (xml, tag) {
			var val = this._readValue(xml, tag);
			return val?val.toLowerCase() === &#x27;true&#x27;:null;
		},
		&#x2F;**
		 * Returns and parses a date from a given tag in an XML document
		 * @method _readDate
		 * @param xml {XMLDocument} The XML document or fragment to parse
		 * @param tag {String} The tag for the value sought
		 * @return {Date} the value read or null if not found
		 * @private
		 *&#x2F;
		_readDate: function (xml, tag) {
			var date, time,
				val = this._readValue(xml, tag);
			if (val) {
				val = val.split(&#x27; &#x27;);
				date = val[0].split(&#x27;-&#x27;);
				time = val[1].split(&#x27;:&#x27;);
				return new Date(date[0], date[1] -1 , date[2], time[0], time[1], time[2]).getTime();
			} else {
				return null;
			}
		},
		&#x2F;**
		 * Returns and parses a color value from a given tag in an XML document
		 * @method _readColor
		 * @param xml {XMLDocument} The XML document or fragment to parse
		 * @param tag {String} The tag for the value sought
		 * @return {String} the RGB value as #rrggbb read or null if not found
		 * @private
		 *&#x2F;
		_readColor: function(xml, tag) {
			var c = this._readValue(xml, tag),
				pad = function(val) {
					return (&#x27;00&#x27; + parseInt(val,10).toString(16)).substr(-2);
				};

			if (c) {
				c = c.split(&#x27;,&#x27;);
				return &#x27;#&#x27; + pad(c[0]) + pad(c[1]) + pad(c[2]);
			} else {
				return null;
			}
		},
		&#x2F;**
		 * Returns the textual contents from a given tag in an XML document
		 * @method _readValue
		 * @param xml {XMLDocument} The XML document or fragment to parse
		 * @param tag {String} The tag for the value sought
		 * @return {String} the content read or null if not found
		 * @private
		 *&#x2F;
		_readValue: function(xml, tag) {
			var el = this._readEl(xml,tag);
			return el?el.textContent:null;
		},
		&#x2F;**
		 * Returns the XML element from given tag in an XML document
		 * @method _readEl
		 * @param xml {XMLDocument} The XML document or fragment to parse
		 * @param tag {String} The tag for the value sought
		 * @return {XMLElement} the element read or null if not found
		 * @private
		 *&#x2F;
		_readEl: function (xml, tag) {
			var el = xml.getElementsByTagName(tag);
			return (el &amp;&amp; el.length)?el[0]:null;
		},
		&#x2F;**
		 * Reads the categories information
		 * @method _xmlReadCategories
		 * @param cats {XMLFragment} collection of categories
		 * @private
		 *&#x2F;
		_xmlReadCategories: function(cats) {
			var c = {};
			Y.each(cats.children, function (cat) {
				c[this._readValue(cat,&#x27;name&#x27;)] = {
					color:this._readColor(cat,&#x27;color&#x27;),
					fontColor:this._readColor(cat,&#x27;font_color&#x27;)
				};
			},this);
			this.set(CATEGORIES, c);

		},
		&#x2F;**
		 * Reads the view information
		 * @method _xmlReadView
		 * @param view {XMLFragment} view information
		 * @private
		 *&#x2F;
		_xmlReadView: function (view) {
			var range = this._readEl(view,&#x27;displayed_period&#x27;),
				cats = this.get(CATEGORIES),
				hiddenCat = this._readEl(view, &#x27;hidden_categories&#x27;).firstChild;

			if (range) {
				this.set(START, this._readDate(range, START));
				this.set(END, this._readDate(range, END));
			}
			while (hiddenCat) {
				cats[hiddenCat.textContent].hidden = true;
				hiddenCat = hiddenCat.nextChild;
			}
		},
		&#x2F;**
		 * Reads the events to show
		 * @method _xmlReadEvents
		 * @param cats {XMLFragment} collection of events
		 * @private
		 *&#x2F;
		_xmlReadEvents: function (events) {
			this._events = [];
			Y.each(events.children, function (event) {
				this._events.push({
					start: this._readDate(event, START),
					end: this._readDate(event,END),
					text: this._readValue(event,&#x27;text&#x27;),
					fuzzy: this._readBoolean(event,&#x27;fuzzy&#x27;),
					locked: this._readBoolean(event,&#x27;locked&#x27;),
					endsToday: this._readBoolean(event,&#x27;ends_today&#x27;),
					category: this._readValue(event, &#x27;category&#x27;),
					description: this._readValue(event, &#x27;description&#x27;),
					icon: this._readValue(event, &#x27;icon&#x27;)
				});

			}, this);

		},
		&#x2F;**
		 * Sugar method to set the URL of the timeline file
		 * @method load
		 * @param url {String} URL of the timeline file
		 * @chainable
		 *&#x2F;
		load: function (url) {
			this.set(URL, url);
			return this;
		},
		&#x2F;**
		 * Requests the timeline information from the configured URL and parses it when it arrives.
		 * Signals its arrival by setting the &#x27;loaded&#x27; configuration attribute
		 * @method _load
		 * @private
		 *&#x2F;
		_load: function () {
			var self = this;
			self.set(LOADED, false);
			Y.io(self.get(URL), {
				on: {
					success: function (id, o) {
						var xml = o.responseXML;
						self._xmlReadCategories(self._readEl(xml,CATEGORIES));
						self._xmlReadView(self._readEl(xml,&#x27;view&#x27;));
						self._xmlReadEvents(self._readEl(xml,&#x27;events&#x27;));
						self.set(LOADED, true);
					}
				}
			});


		},
		&#x2F;**
		 * Adjusts the region information for the given node to make it relative to the container position
		 * @method _getRegion
		 * @param node {Y.Node} node to find the region
		 * @return {Y.Region} region of the node relative to the container
		 * @private
		 *&#x2F;
		_getRegion: function (node) {
			var reg = node.get(REGION);
			reg.left -= this._left;
			reg.top -= this._top;
			return reg;
		},
		&#x2F;**
		 * Draws the bars corresponding to the events in the container
		 * @method _resize
		 * @param container {Y.Node} optional, the container for the bars.  It reads the container attribute if none given
		 * @private
		 *&#x2F;
		_resize: function (container) {
			container = container || this.get(CONTAINER);

			var start = this.get(START),
				end = this.get(END),
				rightEdge = this._width,
				height = this._height,
				scale = rightEdge &#x2F; ( end - start),
				cats = this.get(CATEGORIES),
				bar, width, left, changed = false, region, pointer,hasNoCategory = false,
				TODAY = this.get(STRINGS).today,
				formatDate = function(date) {
					return Y.DataType.Date.format(new Date(date), {format:&#x27;%x&#x27;});
				};

			Y.each(this._events, function(event) {
				if (event.category &amp;&amp; cats[event.category].hidden) {
					return;
				}
				bar = event._bar || BLOCK_TEMPLATE.cloneNode();
				pointer = event._pointer;
				left = Math.round((event.start - start) * scale);
				width = Math.round(((event.endsToday?Date.now():event.end) - event.start) * scale);
				if (left + width &lt; 0 || left &gt; rightEdge) {
					if (event._bar) {
						event._bar.remove(true);
						event._bar = null;
						if (pointer) {
							pointer.remove(true);
							event._pointer = pointer = null;
						}
					}
					changed = true;
					return;
				}
				event._isPoint = width === 0;
				bar.setStyles({
					left: left +PX,
					width: width?width + PX:&#x27;auto&#x27;
				});
				if (!event._bar) {
					event._bar = bar;
					if (event.category) {
						bar.setStyles({
							backgroundColor: cats[event.category].color,
							color: cats[event.category].fontColor
						});
					} else {
						hasNoCategory = true;
					}
					bar.setContent(event.text);
					bar.set(&#x27;title&#x27;, event.text + &#x27;: &#x27; + formatDate(event.start) + &#x27; - &#x27; +  (event.endsToday?TODAY:formatDate(event.end)));
					if (event.fuzzy) {
						bar.addClass(cName(&#x27;fuzzy&#x27;));
					}
					if (event.description || event.icon) {
						bar.addClass(cName(&#x27;hasDescr&#x27;));
					}
					bar.setData(EVENT,event);
				}
				if (!bar.inDoc()) {
					container.append(bar);
					changed = true;
				}
				if (event._isPoint) {
					region = this._getRegion(bar);
					bar.setStyle(LEFT, region.left - region.width &#x2F; 2 + PX);
					if (!pointer) {
						event._pointer = pointer = POINTER_TEMPLATE.cloneNode();
						pointer.setStyle(TOP, height &#x2F; 2 + PX);
					}
				} else {
					if (pointer) {
						pointer.remove(true);
						event._pointer = pointer = null;
						changed = true;
					}
				}
				if (pointer) {
					pointer.setStyle(LEFT, left + PX);
					if (!pointer.inDoc()) {
						container.append(pointer);
					}
				}

			},this);
			if (changed) {
				this._locate();
			}
			container.one(&#x27;.&#x27; + cName(&#x27;noCat&#x27;)).setStyle(&#x27;display&#x27;,hasNoCategory?&#x27;block&#x27;:&#x27;none&#x27;);
		},
		&#x2F;**
		 * Locates the bars so that they don&#x27;t overlap one another.  Range events are drawn above the middle line,
		 * point events below.  Range events may be moved below if the start and end dates are indistinguishable
		 * @method _locate
		 * @private
		 *&#x2F;
		_locate: function () {
			var width, left, region, pointer,
				middle = this._height &#x2F; 2,
				points = [], ranges = [],levels, isPoint,
				mode = this._mode, highest = 0, lowest = 0,
				move = function(bar, levels, i, isPoint) {
					var top;
					switch (mode) {
						case 0:
							top = isPoint? 30 * i + 15:  -30 * (i+1) - 15;
							break;
						case 1:
							top = isPoint? 15 * i + 10:  -15 * (i+1) - 10;
							break;
						case 2:
							top = isPoint? 5 * i + 10:  -5 * (i+1) - 10;
							break;
					}
					highest = Math.min(highest, top);
					lowest = Math.max(lowest, top);
					bar.setStyle(TOP, middle + top + PX);
					if (!levels[i]) {
						levels[i] = [];
					}
					levels[i].push({left:left, width:width});
					pointer = bar.getData(EVENT)._pointer;
					if (pointer) {
						pointer.setStyle(&#x27;height&#x27;, 30 * i + 15);
					}
				};
			this.get(CONTAINER).all(&#x27;div.&#x27; + cName(&#x27;bar&#x27;)).each(function(bar) {
				region = this._getRegion(bar);
				width = region.width;
				left = region.left;
				isPoint = bar.getData(EVENT)._isPoint;
				levels = (isPoint?points:ranges);
				&#x2F;&#x2F; This is to determine container to place it so that it does not overlap with any existing bar
				if (!Y.some(levels, function (level, i) {
					if (!Y.some(level, function (existing) {
						return !(existing.left &gt; (left + width) || left &gt; (existing.left + existing.width));
					})) {
						move(bar, levels, i, isPoint);
						return true;
					}
					return false;
				},this)) {
					move(bar, levels, levels.length, isPoint);
				}
				

			},this);
			highest = Math.max(-highest, lowest);
			if (highest &gt; middle) {
				if (mode &lt; 2) {
					this._mode += 1;
					this._locate();
					this.get(CONTAINER).addClass(cName(&#x27;compact&#x27;));
				}
			} else if (highest &lt; middle &#x2F; 3 ) {
				if (mode) {
					this._mode -=1;
					if (this._mode === 0) {
						this.get(CONTAINER).removeClass(cName(&#x27;compact&#x27;));
					}
					this._locate();
				}
			}
		},
		&#x2F;**
		 * Draws the grid, adjusting the interval in between lines from an hour to ten thousand years
		 * depending on the zoom factor
		 * @method _grid
		 * @private
		 *&#x2F;
		_grid: function () {
			var start = this.get(START),
				end = this.get(END),
				container = this.get(CONTAINER),
				width = this._width,
				height = this._height,
				range = end - start,
				&#x2F;&#x2F; this cover periods of 0:hours, 1:days, 2:months, 3:years, 4:decades, 5:centuries, 6:millenia, 7:tens of millenia
				&#x2F;&#x2F; JavaScript&#x27;s Date object cannot go any further anyway&#x27;
				periods = [1000*60*60, 24, 30, 12, 10, 10, 10, 10],
				period = 1, i, next, p, edge,label, date,

			round = function (what, precision, add) {
				what = new Date(what);
				switch (precision) {
					case 0:
						return new Date(what.getFullYear(), what.getMonth(), what.getDate(), what.getHours() + add, 0, 0).getTime();

					case 1:
						return new Date(what.getFullYear(), what.getMonth(), what.getDate() + add).getTime();

					case 2:
						return new Date(what.getFullYear(), what.getMonth() + add, 1).getTime();

					default:
						precision = Math.pow(10,precision - 3);
						return new Date(Math.floor(what.getFullYear() &#x2F; precision) * precision + (add?precision:0), 0, 1).getTime();



				}
			};
			container.all(&#x27;div.&#x27; + cName(&#x27;grid&#x27;)).remove(true);

			for (i = 0; i &lt; periods.length; i+=1) {
				period *= periods[i];
				&#x2F;&#x2F; check if the period is wider than 20 pixels in the current container
				if (width &#x2F; range * period &gt; 20) {
					break;
				}
			}
			edge = round(start, i, 0);
			while (edge &lt; end) {
				next = round(edge, i, 1);
				date = new Date(edge);
				p = GRID_TEMPLATE.cloneNode();
				label = [date.getHours()];
				if (label[0] === 0) {
					label[1] = date.getDate();
					if (label[1] === 1) {
						label[2] = date.getMonth();
						if (label[2] === 0) {
							label[3] = date.getFullYear();
						}
						label[2] = Y.DataType.Date.format(date, {format: &#x27;%b&#x27;});
					}
				}

				p.setContent(label.slice(Math.min(3,i)).join(&#x27;, &#x27;));
				p.setStyles({
					width:Math.round((next - edge) &#x2F; range * width) - 1  + PX,
					left:Math.round((edge - start)&#x2F; range * width) + PX,
					paddingTop: height&#x2F;2  + PX,
					height: height&#x2F;2 + PX
				});
				container.append(p);
				edge = next;

			}


		},
		&#x2F;**
		 * Sugar method to set the container attribute.
		 * @method render
		 * @param container {String | Node} CSS selector or reference to the container node.
		 * @chainable
		 *&#x2F;
		render: function (container) {
			this.set(CONTAINER, container);
			return this;
		},
		&#x2F;**
		 * Renders the timeline in response to the container being set and the timeline file loaded
		 * @method _render
		 * @private
		 *&#x2F;
		_render:function() {
			var container = this.get(CONTAINER),
				region, cats;
			if (!( container &amp;&amp; this.get(LOADED))) {
				return;
			}
			container.addClass(cName());

			container.setContent(&#x27;&#x27;);
			Y.each(this._events, function (event) {
				delete event._pointer;
				delete event._bar;
				delete event._isPoint;
			});


			region = container.get(REGION);
			this._left = region.left;
			this._top = region.top;
			this._height = region.height;
			this._width = region.width;

			container.append(Y.Node.create(&#x27;&lt;div class=&quot;&#x27; + cName(&#x27;divider&#x27;) + &#x27;&quot;&#x2F;&gt;&#x27;));
			cats = container.appendChild(Y.Node.create(Lang.sub(CATEGORIES_TEMPLATE,this.get(STRINGS))));
			Y.each(this.get(CATEGORIES), function (cat, name) {
				if (!cat.hidden) {
					cats.append(Y.Node.create(&#x27;&lt;p style=&quot;color:&#x27; + cat.fontColor + &#x27;;background-color:&#x27; + cat.color + &#x27;&quot;&gt;&#x27; + name + &#x27;&lt;&#x2F;p&gt;&#x27;));
				}
			});
			this._descr = container.appendChild(Y.Node.create(&#x27;&lt;div class=&quot;&#x27; + cName(&#x27;descr&#x27;) + &#x27;&quot;&#x2F;&gt;&#x27;));

			this._grid();
			this._resize(container);

			container.delegate(&#x27;click&#x27;,this._showDescr,&#x27;div.&#x27; + cName(&#x27;bar&#x27;),this);
			container.delegate(
				&#x27;hover&#x27;,
				function(ev) {
					ev.target.setStyle(&#x27;zIndex&#x27;, 9);
				},
				function(ev) {
					ev.target.setStyle(&#x27;zIndex&#x27;, 0);
				},
				&#x27;div.&#x27; + cName(&#x27;bar&#x27;)
			);
			container.on(&#x27;gesturemovestart&#x27;, this._startMove, {}, this);
			container.on(&#x27;gesturemove&#x27;, this._dragMove, {}, this);
			container.on(&#x27;gesturemoveend&#x27;, this._dragMove, {}, this);
			Y.on(&#x27;mousewheel&#x27;, this._mouseWheel, this);
			return;
		},
		&#x2F;**
		 * Hides de extended description
		 * @method _hideDescr
		 * @private
		 *&#x2F;
		_hideDescr: function() {
			this._descr.setStyle(&#x27;display&#x27;, &#x27;none&#x27;);
		},
		&#x2F;**
		 * Shows the extended description above the event bar clicked
		 * @method _showDescr
		 * @param ev {Event Façade} to help locate the bar clicked
		 * @private
		 *&#x2F;
		_showDescr: function(ev) {
			var bar = ev.target,
				event = bar.getData(EVENT);
			this.fire(SHOW_DESCR, {
				bar: bar,
				event: event,
				callback: this.showDescr
			});
		},
		_defShowDescr: function (ev) {
			var bar = ev.bar,
				event = ev.event;
			this.showDescr(bar, event);
		},
		showDescr: function (bar, event) {
			var	barRegion = this._getRegion(bar),
				descr = this._descr,
				descrRegion,
				barMidPoint = barRegion.left + barRegion.width &#x2F;2,
				third = this._width &#x2F; 3;

			if (event.description || event.icon) {
				descr.setContent((event.icon? &#x27;&lt;img src=&quot;data:image&#x2F;png;base64,&#x27; + event.icon + &#x27;&quot;&gt;&#x27;:&#x27;&#x27;) + event.description);
				descr.setStyles({
					display:&#x27;block&#x27;,
					top:0
				});
				descr.removeClass(cName(LEFT));
				descr.removeClass(cName(CENTER));
				descr.removeClass(cName(RIGHT));
				descrRegion = this._getRegion(descr);

				if (barMidPoint &lt; third) {
					descr.setStyle(LEFT, Math.max(barMidPoint,0) + PX);
					descr.addClass(cName(LEFT));
				} else if (barMidPoint &lt; third * 2) {
					descr.setStyle(LEFT, barMidPoint - descrRegion.width &#x2F; 2  + PX);
					descr.addClass(cName(CENTER));
				} else {
					descr.setStyle(LEFT, Math.min(barMidPoint,this._width - 30) - descrRegion.width + PX);
					descr.addClass(cName(RIGHT));
				}
				descr.setStyle(TOP, Math.round(barRegion.top - descrRegion.height - 20) + PX);
			}
		},
		&#x2F;**
		 * Saves the initial position of a drag and the initial values of the start and end dates
		 * @method _startMove
		 * @param ev {Event Façade} information about the cursor at the start
		 * @private
		 *&#x2F;
		_startMove: function (ev) {
			ev.halt();
			this._hideDescr();
			this._pageX = ev.pageX;
			this._start = this.get(START);
			this._end = this.get(END);
		},
		&#x2F;**
		 * Respondes to the movement of the cursor at whatever rate the system sends the signal
		 * by updating the start and end times of the display, either panning or zooming
		 * @method _dragMove
		 * @param ev {Event Façade} event information, specially cursor coordinates and state of the control key
		 * @private
		 *&#x2F;
		_dragMove: function (ev) {

			var start = this._start,
				end = this._end,
				width = this._width,
				deltaX = Math.round((ev.pageX - this._pageX) &#x2F; width * (end - start));

			if (deltaX) {
				this.set(START,  start -  deltaX);
				if (ev.ctrlKey) {
					this.set(END,  end +  deltaX);
					this._locate();
				} else {
					this.set(END,  end -  deltaX);
				}
				this._resize();
				this._grid();
			}
		},
		&#x2F;**
		 * Listener for the mouse wheel change.  It will zoom or pan depending on the state of the control key.
		 * @method _mouseWheel
		 * @param ev {Event Façade} the state of the control key and the direction of the mouse wheel roll is extracted from it
		 * @private
		 *&#x2F;
		_mouseWheel: function (ev) {
			if (ev.target.ancestor(&#x27;#&#x27; + this.get(CONTAINER).get(&#x27;id&#x27;),true)) {
				ev.halt();

				this._hideDescr();
				var start = this.get(START),
					end = this.get(END),
					deltaX = (end - start) * 0.1 * (ev.wheelDelta &gt; 0?-1:1);

				this.set(START, start - deltaX);
				if (ev.ctrlKey) {
					this.set(END, end + deltaX);
					this._locate();
				} else {
					this.set(END, end - deltaX);
				}
				this._resize();
				this._grid();
			}
		}
	},
	{
		ATTRS: {
			&#x2F;**
			 * Stores the categories, indexed by category name.  Each category contains:&lt;ul&gt;
			 * &lt;li&gt;&lt;b&gt;color&lt;&#x2F;b&gt;: {string} Background color for the bar in #rrggbb format&lt;&#x2F;li&gt;
			 * &lt;li&gt;&lt;b&gt;fontColor&lt;&#x2F;b&gt;: {string} Color for the text in the bar in #rrggbb format&lt;&#x2F;li&gt;
			 * &lt;li&gt;&lt;b&gt;hidden&lt;&#x2F;b&gt;: {Boolean} Events in this category should not be shown&lt;&#x2F;li&gt;
			 * &lt;&#x2F;ul&gt;
			 * @attribute categories
			 * @type {Object}
			 * @default {}
			 *&#x2F;
				
			categories: {
				validator: Lang.isObject,
				value:{}
			},
			&#x2F;**
			 * Start time (left edge) of the current timeline, in miliseconds
			 * @attribute start
			 * @type integer
			 * @default one month before current time
			 *&#x2F;
			start: {
				validator: Lang.isNumber,
				value: new Date(Date.now() - 1000*60*60*24*30).getTime() &#x2F;&#x2F; previous month
			},
			&#x2F;**
			 * End time (right edge) of the current timeline, in miliseconds
			 * @attribute end
			 * @type integer
			 * @default one month after current time
			 *&#x2F;
			end: {
				validator: Lang.isNumber,
				value: new Date(Date.now() + 1000*60*60*24*30).getTime() &#x2F;&#x2F; next month
			},
			&#x2F;**
			 * A reference to the HTML for rendering the timeline
			 * @attribute container
			 * @type {String | Y.Node}  A reference to a node or a CSS selector.  It will always be returned as a Node reference
			 *&#x2F;
			container: {
				setter: function (val) {
					return Y.one(val);
				}
			},
			&#x2F;**
			 * URL of the timeline file to be displayed
			 * @attribute url
			 * @type {String}
			 *&#x2F;
			url: {
				validator: Lang.isString
			},
			&#x2F;**
			 * Signals whether the timeline file has been loaded or not
			 * @attribute loaded
			 * @type {Boolean}
			 * @default false
			 *&#x2F;
			loaded: {
				validator: Lang.isBoolean,
				value: false
			},
			&#x2F;**
			 * Localizable strings meant to be seen by the user
			 * @attribute strings
			 * @type {Object}
			 * @default English strings
			 *&#x2F;
			strings: {
				value: {
					categories:&#x27;Categories&#x27;,
					noCategory: &#x27;-no category-&#x27;,
					today: &#x27;today&#x27;
				}
			}

		}
	}
);



    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
