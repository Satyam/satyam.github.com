---
title: "Programación a la antigua"
date: "2025-09-26"
categories: ["Historia/Informática"]
language: "es-ES"
draft: true
---
Programación a la antigua

---

La pandemia obligó a muchos a volcarse a la Internet, como ya no se podía ir a las tiendas, las compras on-line se hicieron más habituales, todo parece estar accesible a través de la pantalla.   Aún mis jóvenes colegas informáticos, y al decir jóvenes, desde mi punto de vista, abarco algunos que puede que estén llegando a la jubilación, no saben o no recuerdan las épocas en que las cosas no eran tan rápidas o fáciles.

Recientemente leí un artículo sobre la "Historia de la Programación" y me asombró qué poco sabía el autor de lo que precedió a la Commodore 64 o alguna de las tantas máquinas conque muchos de nosotros comenzamos a programar en Basic.  El epítome de la era anterior a la computadora personal estaba representado por la imagen de una tarjeta perforada IBM también conocida como Hollerith, por su inventor Herman Hollerith, quien fundó una de las empresas que, junto a otras, fueron el origen de IBM.

<figure>
  <a 
    title="Pete Birkinshaw from Manchester, UK, CC BY 2.0 <https://creativecommons.org/licenses/by/2.0>, via Wikimedia Commons" 
    href="https://commons.wikimedia.org/wiki/File:Used_Punchcard_(5151286161).jpg"
  >
    <img alt="Tarjeta Hollerith" src="assets/img/512px-Used_Punchcard_(5151286161).jpg">
  </a>
  <figcaption>Tarjeta perforada Hollerith</figcaption>
</figure>

Esta tarjeta no era de uso universal.  IBM no era el único fabricante de sistemas de procesamiento de datos y aunque era por lejos el más importante, había otras que usaban otros medios como cintas de papel de 5 bits de las usadas en telegrafía, o de 7 bits ASCII como el de las Teletype. También había tarjetas de plástico con una cara recubierta de material magnetizable, o con una cinta magnética (como muchas tarjetas de crédito todavía tienen) que permitían del otro lado escribir la identificación del programa o los datos que contenía (¡con marcador de felpa, que si no se estropea!).   Tanto las cintas o la tarjeta magnética almacenaban programas completos, no simplemente una línea de 80 caracteres como la tarjeta IBM.  IBM misma finalmente cambió las tarjetas por el diskette o disco flexible, que en un principio era de 8 pulgadas de lado, poco más de 20cm que, para la época de la PC de IBM, había pasado a 5 &frac14;" o poco más de 13cm.

Aunque es cierto que la asociación mental entre esta tarjeta de cartulina y el pasado de la computación es fuerte, se queda corta en representar la gran diferencia en la forma de procesar datos actual de la de entonces.  Lo que al programador actual le resulta más difícil concebir son

*  la escasez de memoria y 
*  la falta de medios de almacenamiento de acceso aleatorio.

Todos habremos visto antiguas películas de ciencia ficción con centros de datos llenos de paneles con luces, que es parcialmente cierto, y múltiples unidades de cinta magnética, con sus carretes de cinta girando permanentemente a un lado y al otro.  Durante mucho tiempo las cintas magnéticas fueron el principal medio de almacenamiento de datos. Estas cintas son de acceso puramente secuencial, un registro va detrás del otro y para llegar a cualquiera de ellos hay que pasar por todos los que le preceden en esa cinta.  En algún centro de cómputos podía haber algunas unidades de discos, equipos del tamaño de una lavadora pero, al principio, raramente se usaban para almacenamiento permanente pues eran caros y de poca capacidad pero también porque el procesamiento de datos estaba pensado para funcionar sin ellos, y si la cosa funcionaba, para qué cambiar.

Los discos comenzaron a ser una opción práctica cuando comenzaron a aparecer unidades removibles de alta capacidad (para la época) de 150MB o 300MB.  Un *pack* de 300MB como el que se muestra en la imagen siguiente contenía casi lo que dos cintas magnéticas ó 3,7 millones de tarjetas perforadas.  

<figure>
 <a title="Steve Parker, CC BY 2.0 &lt;https://creativecommons.org/licenses/by/2.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Disk_drive_of_professional_large_computer_system_(1970s)_with_removable_disk_pack_as_storage_medium_inside,_from_%27International_Computers_Limited%27.jpg">
    <img alt="Batería de unidades de discos magnéticos removibles" src="assets/img/1024px-Disk_drive.jpg">
  </a>
  <figcaption>Fila de unidades de discos magnéticos de la década de 1970. La unidad abierta muestra el *pack* de disco con sus 11 platos y detrás se ve la caja donde se guarda cuando se retira de la unidad. En esta época una unidad de este tipo debía tener unos 300MB.</figcaption>
</figure>

Pero, hasta entonces, la cinta magnética era la reina aunque, claro, tenía sus inconvenientes.  No se puede andar avanzando y retrocediendo la cinta en busca de un registro específico, había que procesarlos en el orden en que aparecían. Más aún, no se puede actualizar un registro individual en una cinta.  Técnicamente es posible pero no es práctico, como veremos más tarde.   Así pues, veamos cómo habríamos hecho un proceso muy simplificado de actualización de inventario en una empresa comercial en un sistema con poca memoria y sin discos.

## Procesando el inventario

Por un lado, tendremos la cinta con los datos de todos los artículos del inventario.  A esta se le dice una cinta *maestra* porque contiene datos fundamentales.  Por otro, la pila de tarjetas perforadas con los artículos despachados a los clientes, con su número de artículo, la fecha de salida del depósito, la cantidad, el número de cliente a quien se le ha enviado, el número de la orden de compra y cuantos datos se necesiten para documentar esa salida. En este caso, al actualizar el inventario, los datos del cliente son irrelevantes, pero estas mismas tarjetas se podrán usar para facturación, donde los datos del cliente, obviamente, son necesarios. A esta pila de tarjetas se le llama de *movimientos*, lo cual en este caso es muy apropiado porque se trata de movimientos concretos de mercadería, pero en realidad podría tratarse de registros de horario de entrada o salida de personal, depósitos o extracciones de clientes de un banco o cualquier otro tipo de actividad.

Aquí ya vemos una gran diferencia en cómo se hacían las cosas hace unas décadas.  Actualmente, un *movimiento* desencadenaría un buen número de actualizaciones en múltiples tablas en una o más bases de datos; la actualización del inventario y la emisión de la factura, se harían casi simultáneamente.  Cuando todo se hacía con cintas magnéticas, la actualización del inventario y la facturación se hacían en momentos diferentes por dos buenas razones. 

Las unidades de cintas magnéticas eran caras y si estaba montada la cinta maestra con el inventario, llamada *maestro de inventario* para abreviar, entonces se actualizaba el inventario; para hacer facturación había que tener montada el *maestro de clientes*, esto es la cinta maestra con los datos de los clientes..  

Luego estaba el problema del acceso secuencial.  Aunque hubiera suficientes unidades de cinta como para tener todas las cintas maestras montadas, se perdería muchísimo tiempo avanzando y retrocediendo cada una de las cintas para procesar, digamos el artículo 147 vendido al cliente 398 y luego tener que avanzar la cinta de inventario y rebobinar la de clientes para luego hacerla avanzar si tengo que procesar el artículo 200, que está más adelante en la cinta, vendido al cliente 24 que al estar antes que el 398 que se acaba de procesar, obliga a rebobinar y buscar secuencialmente desde el principio.  Si suena como un enredo es porque, en la práctica, lo sería.  

Como se puede ver, no se puede operar eficientemente de esta forma.  Los carretes con las cintas maestras no pueden andar avanzando y retrocediendo constantemente para cada movimiento. La forma correcta de hacerlo es que las cintas siempre avancen procesando la información a medida que va apareciendo.

Los registros del maestro de inventario vienen ordenados por número de artículo.  Las tarjetas de movimientos pueden estar en cualquier orden, posiblemente de distintos operadores, quizás de distintos almacenes, apiladas en cualquier orden, así que no se sabe.  Lo primero que se debe hacer es ordenar las tarjetas por número de artículo, para que coincida con el maestro de inventario.   Este ordenamiento, en la jerga, se le dice 'sortear', una deformación del verbo 'sort', que en inglés significa clasificar, aunque en jerga informática se usa también para ordenar alfabética o numéricamente, porque originalmente este proceso se hacía en máquinas clasificadoras.

<figure>
 <a title="waelder, CC BY-SA 3.0 &lt;http://creativecommons.org/licenses/by-sa/3.0/&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Punch_card_sorter.JPG">
    <img alt="Una clásica clasificadora electromecánica" src="assets/img/1024px-Punch_card_sorter.jpeg">
  </a>
  <figcaption>Clásica clasificadora electromecánica de tarjetas perforadas usada para 'sortear' las tarjetas.</figcaption>
</figure>

La información en las tarjeta se dividía por columnas.  Digamos que las primeras 8 columnas de la tarjeta de movimientos de inventario fueran la fecha de salida del artículo, en año, mes y día todo corrido, por ejemplo, 20250928.  Luego el número de artículo, en digamos, 8 caracteres numéricos y así siguiendo con el resto de la información, número de orden de compra, cantidad, número de cliente, etc.  El operador de la clasificadora deberá poner la pila de tarjetas la bandeja de entrada, la pieza que sobresale arriba a la derecha en la máquina de la imagen, con el bloque que las presiona hacia abajo. Luego, debe programar cada una de las casillas de salida.  Debe pedir que en una casilla vayan las tarjetas que en la columna 16, la posición de las unidades en el número de artículo (8 de la fecha más 8 del número de artículo), vayan las tarjetas que tienen un 0 en esa posición.  En la siguiente casilla habrán de ir las que tienen un 1 en esa posición, y luego un 2, un 3 y así siguiendo. Siempre se comienza la clasificación por la posición del dígito menos significativo, unidades, decenas, centenas, miles y así siguiendo. (o la letra, según el caso). Una forma de pensarlo es que la última de las pasadas es la que tiene la última palabra en lo que se ordena, por lo que corresponde que sea el dígito más significativo el que mande.

Cuando termine esta primera pasada, en una casilla, la primera (a la derecha en este caso), tendrá todas las tarjetas cuyo número de artículo termine en 0, en la siguiente los que terminen en 1 y así siguiendo, con dos casillas vacías y la decimotercera con las fallidas.   El operador recogerá y apilará las tarjetas de cada una de esas casillas, de derecha a izquierda y las volverá a poner en el cajón de entrada.  Luego reprogramará las casillas para volver a clasificar nuevamente de 0 a 9 pero en la columna 15, la de las decenas, y las volverá a apilar de derecha a izquierda. Repetirá el proceso para las columnas de la 14 a la 9.  Si hubiera querido ordenar las tarjetas en orden descendente, habría bastado con apilar las tarjetas de las casillas de izquierda a derecha.  Al final, tendrá las tarjetas perfectamente ordenadas por número de artículo.  Y si no me creen, jueguen a ordenar números siguiendo este proceso en papel y lápiz.

¿Por qué 13 casillas?  Porque las tarjetas tenían 12 filas entonces, había casillas de salida para cada una de esas 12 filas y la decimotercera para el descarte, tarjetas que posiblemente se hubieran dañado o que no tuvieran ninguna perforación en esa columna y no cumplieran ninguna de las condiciones previas.  Las letras usaban combinaciones de 2 perforaciones en la misma columna y los símbolos 3.  Ordenar alfabéticamente en lugar de numéricamente requería hasta 3 pasadas por cada columna.

Como leer tarjetas es lento, lo habitual era pasar los lotes de tarjetas a una cinta magnética.  En algunos centros de cómputos era tal el volumen de tarjetas perforadas a procesar que había máquinas dedicadas a transferir lotes de tarjetas a cinta para no ocupar el procesador principal en algo tan trivial.

En ese caso, el *sort* se hacía de cinta a cinta.  Esto era un proceso que se llamaba *sort-merge* o sea, clasificar y unir.  Como los procesadores no tenían mucha memoria, el *sort* no se podía hacer directamente en la memoria del procesador en una sola pasada.  Entonces, lo que se hacía era leer tantos registros como cupieran en la memoria, ordenarlos allí y luego, grabar ese lote en una cinta magnética auxiliar.  Luego se leía otro lote, se ordenaba en memoria y se grababa en cinta y así con todos los lotes que fuera necesario distribuyéndolos en tantas cintas como hubiera disponibles.  Cada cinta terminaba con varios lotes de datos.  Entonces, venía la etapa de unión (*merge*) en el que se entremezclaban ordenadamente los registros de los varios lotes de las cintas y el resultado iba a una nueva cinta.  

Por ejemplo, digamos que una cinta A tenía un lote con los números 1, 2, 3, 7, 8, 12 y 15 y otra cinta `B` tenía un lote con 4, 5, 9, 10, 14 y 16.  Entonces el procesador lee el primer número de cada lote, en este caso `A:1` y `B:4`.  Como el 1 es menor que el 4 lee de la cinta `A`: 1, 2, 3, 7.  Pero el 7 es mayor que el 4 así que lo retiene en memoria que ahora pasa de `A:1` y `B:4` a `A:7` y `B:4`.  Entonces lee de la cinta `B`: 4, 5, 9, pero el 9 es mayor que el 7, entonces actualiza el `A:7` y `B:4` a `A:7` y `B:9` y pasa a leer de la primera cinta `A` y así hasta terminar los lotes. 

Si los datos eran muchos y cada una de las cintas auxiliares tenía varios lotes, el proceso debía repetirse varias veces.  En cada pasada, los lotes se hacían cada vez mas grandes y había menos de ellos, hasta que en algún momento, termina habiendo un único lote en una única cinta, que es el resultado final. El *sort* era un proceso utilitario, incluido con el software de base de cualquier sistema y bastaba con decirle las columnas de los datos a ordenar, en que unidad de cinta o lectora de tarjetas estaban los datos originales, en qué unidad debían grabarse los datos ordenados y cuántas unidades iba a disponer con carretes de cinta *de borrador* y el sistema lo manejaba todo.

Si el centro de cómputos disponía de unidades de disco los múltiples lotes de datos intermedios se grababan en estos en lugar de cintas auxiliares y el *merge* requería una sola pasada.  De hecho, este solía ser el primer uso que se les dio a los discos o tambores magnéticos, servían como una extensión de la memoria principal, que por aquellas épocas, no era tan grande.

Comenzaba, entonces, el proceso de actualización de inventario.  En una unidad de cinta estaba el maestro de inventario, en otra la cinta con los movimientos de salida de los artículos, ya ordenada por número de artículo.  En otra unidad se pone una cinta magnética en blanco o una cuyo contenido hubiera quedado obsoleto y se pueda reutilizar para algo distinto.  Otras unidades tendrán cargadas cintas auxiliares para otros fines, que no viene al caso detallar aquí.

Recién en este punto es cuando se ejecuta el programa de actualización.  Se lee la primera tarjeta de salida de mercadería.  Se lee el número de artículo.  Se compara el número del artículo con el último número de artículo que se ha leído del archivo maestro y está en memoria.  Como todavía no se ha leído ninguno, digamos que tiene todos ceros.  Si los números de artículo coinciden, estamos todavía actualizando el mismo artículo.  En este caso, al no haber ninguno, no pueden coincidir.  Digamos que el primer envío es del artículo 10.  Del maestro de artículos se lee, artículo 1, artículo 2, 3, 4 y así siguiendo hasta el artículo 10.  Todos los registros que se fueron leyendo del maestro de artículos, del 1 al 9, se copian a la cinta de salida tal cual. El 10 se retiene en memoria.

Con el registro del artículo 10 en memoria, se le resta la cantidad enviada al stock actual. Luego se lee el siguiente movimiento de salida de artículos.  ¿Sigue siendo el mismo artículo?. Si es así se le resta también la cantidad de este movimiento. Si no es así, se graba el registro del artículo 10 en la cinta de salida, ya con la cantidad en existencia actualizada.  

Posiblemente se compare las existencias actualizadas con el mínimo de reposición, esto es, con el mínimo de artículos necesarios para avisar a compras que vayan reponiendo.  Este dato también está en el mismo registro del maestro de inventario.  Si las existencias están bajo mínimos, se graba un registro en alguna cinta de salida para luego emitir las órdenes de compra a nuestros proveedores.    

Digamos que el registro recién leído es para el artículo 15.  Entonces, se leen y copian los registros de la cinta maestra para los artículos 11, 12, 13 y 14 a la cinta de salida y se repite el proceso como se hiciera con el artículo 10.

Como se puede apreciar, la cinta maestra con el inventario no se modifica. Se genera una copia actualizada en una nueva cinta.  Esta cinta es una nueva *generación* del mismo archivo maestro.  Cada carrete lleva una etiqueta con un número de carrete y opcionalmente una descripción.  El número de carrete es lo más importante porque en las estanterías donde se guardan las cintas, la *cintoteca*, lo único que se ve son los cantos de las cajas de las cintas, como si del lomo de un libro se tratara, y allí no hay mucho espacio donde escribir.  Había todo un proceso administrativo para el buen manejo de las cintas, de hecho, había programas para administrarlas.  Habitualmente se mantenían 3 generaciones de cintas para cada archivo maestro, maestro propiamente dicho, padre y abuelo.  Cuando se generaba una nueva cinta, la que había sido *maestra* pasaba a *padre*, el *padre* a *abuelo* y el *abuelo* pasaba a disponible, para reutilizar la cinta en cualquier otra cosa. También se guardaban las cintas de movimientos, en este caso las salidas de almacén. De esta forma, si se perdiera o arruinara alguna de las generaciones, se puede reconstruir a partir del ancestro directo y la cinta de salidas de almacén.   Según la importancia, algunas cintas podían ir a un almacén de cintas en otra ubicación para resguardo en caso de desastre en que se perdieran las cintas de trabajo.

## Facturación

Todo el producto que salió del almacén ha de ser facturado a sus compradores.  El proceso, que actualmente haríamos en paralelo con la actualización del inventario, en otra época requería un proceso separado.  Cambiar de un proceso a otro requería bastante trabajo manual de parte de los operadores del sistema.  En primer lugar había que desmontar casi todas las cintas magnéticas, guardarlas en la *cintoteca*, hacer el cambio generacional en los maestros, registrar apropiadamente todos estos cambios y recién entonces comenzar a preparar el nuevo proceso.

Una cinta que se reutilizará será la de movimientos de inventario.   Otra que quedará a mano, aunque no montada en ninguna unidad de cinta, es la del listado de artículos para reposición, que requerirá un proceso posterior, posiblemente imprimir un listado para el departamento de compras, pero que no veremos aquí.

Podría parecer que bastaría con montar la cinta con el maestro de clientes para arrancar el proceso, pero nos encontramos con un problema, este maestro tiene sus registros ordenados por número de cliente mientras que la cinta de movimientos está ordenada por número de artículo, tal como se usó para actualizar el inventario.   Por ello, antes de comenzar la facturación tenemos que obtener una copia de esta cinta ordenada por número de cliente y número de orden de compra. Los auxiliares de operación entonces tendrán que montar una cinta en blanco para los movimientos ordenados bajo el nuevo criterio y cintas auxiliares en tantas unidades de cinta como queden disponibles, para guardar los lotes de datos en que se fragmenta el *sort-merge*.

Dado que el *sort* es un proceso utilitario, el operador simplemente tendrá que configurar la operación, indicar qué unidades de cinta contienen qué cinta y qué función cumple (entrada, salida o auxiliares) y los criterios de ordenación.  Como esta es una operación habitual, en lugar de hacerlo manualmente desde la consola, si es que disponía de una, lo más habitual es que tuviera paquetes de tarjetas perforadas con las instrucciones ya preparadas.   En algunos sistemas que usaban máquinas de teletipo como consola, era habitual tener rollos de cinta perforada con las instrucciones necesarias.

Para evitar tener que reconfigurar los procesos cada vez que se ejecutaban era habitual montar siempre el mismo tipo de cinta en la misma unidad pero, por ejemplo, si una unidad no estaba disponible por averías o lo que fuera, el operador tenía que o perforar una o más tarjetas e intercalarlas en el paquete o perforar una nueva cinta de papel.

Claro que antes todavía de hacer el *sort* había que *cargar* el *sort*.  Nosotros estamos acostumbrados a hacer clic en un icono, o escribir un comando en la consola, pero muchos todavía recordarán cuando, para ejecutar un programa en las primeras microcomputadoras como las Commodore, Sinclair y tantas otras, había que enchufar un cartucho con el programa o leer el programa de un casete de audio. Lo mismo ocurría entonces.  Primero había que cargar el programa en la memoria, lo cual se hacia desde una cinta magnética, pequeños carretes de cinta que el operador tenía a mano en una estantería cercana pues se usaban continuamente.  Una vez cargado el programa, este quedaba en suspenso y se desmontaba la cinta con el programa para, recién entonces montar las cintas para el proceso en sí, en este caso el *sort*.

<figure>
  <a 
    title="Digital_PDP11-IMG_1498.jpg: Rama &amp; Musée Bolo derivative work: Morn, CC BY-SA 2.0 FR &lt;https://creativecommons.org/licenses/by-sa/2.0/fr/deed.en&gt;, via Wikimedia Commons" 
    href="https://commons.wikimedia.org/wiki/File:Digital_PDP11-IMG_1498_cropped.jpg">
    <img alt="Digital PDP-11" src="assets/img/1024px-Digital_PDP11-IMG_1498_cropped.jpg">
  </a>
  <figcaption>Panel de control de una PDP-11 de Digital Equipment Corporation</figcaption>
</figure>

Ese era uno de los usos de las llaves y diales que las viejas computadoras llevaban en esos grandes paneles con luces.  Cada unidad de cinta, cada lectora de tarjetas o cintas perforadas tenía una *dirección*, un código numérico que la identificaba.  Para cargar cualquier programa, el operador debía marcar con estas llaves o diales el número de la unidad que tenía el programa y darle al botón de arranque.  Una vez cargado el programa y montadas todas las cintas que se necesitaban, había que indicarle, con estas mismas llaves y diales, desde cuál unidad debía leer las tarjetas o la cinta perforada con la configuración del proceso.  Cada llave individual representaba un bit, la posición de la llave un cero o un uno.  Como al usar binario es fácil equivocarse, era habitual agrupar los bits de 3 en 3 representando los números en *octal* que usaba 8 valores para cada dígito, del 0 al 7.  Por eso, las llaves se agrupaban de a 3 en 3 usando diferente color para las llaves y el fondo.



$$$

Como parte de la configuración podría ser variable, por ejemplo, en qué unidades se habían puesto las cintas auxiliares, el operador, si usaba tarjetas, simplemente insertaba las tarjetas que identificaran las unidades a usar dentro del paquete antes de procesarlo.  Si la consola usaba cinta de papel, la misma c

---
Por ejemplo, ya se puede imprimir la cabecera de la factura, nombre del cliente, dirección, identificación fiscal, etc.  Pero, en la práctica, no se hace así porque las impresoras son relativamente lentas y no justifica tener el procesador y varias unidades de cinta esperando que la impresora termine lo suyo.  Lo habitual es que todo lo que se deba imprimir vaya a una cinta auxiliar de donde, otro programa posiblemente ejecutándose en un equipo de menor envergadura, se dedique a imprimir todo lo necesario.  De hecho, esto todavía se hace así, es lo que llamamos una *cola de impresión*, la diferencia es que en los sistemas operativos modernos, esta *cola de impresión* la gestiona el mismo sistema operativo, se guarda en disco y el usuario ni se entera.  En aquella época, la cola de impresión era un carrete de cinta magnética.
---
La misma cinta de movimientos de salida de almacén se ha de utilizar también en la actualización de las existencias o *stock* de mercaderías, pero no ordenada como está.  Para poder procesar inventario, se debe generar otra cinta de movimientos esta vez ordenada por número de artículo, para procesar en conjunto con la cinta maestra de inventario.

Como es más que evidente la ejecución de un proceso, facturación, inventario, nómina, etc,  requería mucho más que ejecutar un programa sobre una gran base de datos o en la nube.   Implicaba una serie de tareas auxiliares, como ordenar los movimientos según correspondiera, distribuyendo las cintas necesarias en las unidades que estuvieran disponibles o, si lo hubiera, asignar el espacio en disco para hacer el *sort*. Sí, en aquella época, los archivos en disco no crecían en la medida que se necesitaba, el operador debía reservar un área del disco, usualmente contigua, para cada uso.


montar la generación correcta de cada una de las cintas maestras necesarias en cada operación en las unidades de cinta, que el operador configurara el *job* (la tarea) diciéndole en qué unidad de cinta había qué cinta, en qué impresora había qué formulario pre-impreso



-----

You can't waste time spinning a tape around looking for a specific record, you had to process them as they came.  Moreover, you couldn't update a tape.  Technically, you could, but it wasn't a good idea.  It was faster to group several records into a block of data that could be efficiently recorded at once.  So, to update one record, you would have to rewrite the whole block, including the adjacent records. Computers back then didn't have enough memory to keep large blocks in it, you were better off letting the data stream through.  Also, blocks of data had to be separated by gaps, to allow the mechanism of the tape drive to brake after reading one block and accelerate to read the next, when the main computer was ready to accept it.  If you wanted to rewrite a tape, you had to increase the gap, to make sure that any mechanical issue won't get your updated block overlap the next.   But, if you increased the gap, your tape won't hold as much data. Thus, you never updated a tape.  Processing meant reading from one generation of a tape, that is, a file, and creating a new generation of that updated file on a blank tape. This would have the advantage that you could always restart the process at any time since you always kept the generation of data you started the process with.

So, the first order of business in any process was getting all the input data in the same order as the master tape.  If your customer tape is sorted by customer number, you first had to sort your cards by that same customer number.   So, your invoicing might go like this, read the first card with the first item of a purchase order.  Is the customer number the same as the one for the customer record you have in memory?  Since you haven't read any, it is not.  Then read from the customer master record until you find the record for the customer you are invoicing, copying the skipped records to the output tape.  Do all the processing for that purchased item for that customer.  This might involve generating auxiliary tapes, for example, for the finance department, which might be processed later on.

Read the next card with the next item.  Is the same customer number as the record in memory?  Does the item belong to the same purchase order? If the PO is different, you can go ahead and print the invoice for that PO.  If your system had enough memory, the PO might have been held in memory, if you had a magnetic disk or drum, you might have it on a temporary file, otherwise you probably had it on an auxiliary tape, if so, you would process that tape at a later time to avoid having the whole invoicing process waiting for the printer.   Some manufacturers offer auxiliary printing computers that would take one such tape and handle multiple line printers to offload that relatively slow process to a separate, and noisy, process. Yes, they were usually in a separate fishbowl.

Is the customer number the same as the one you still have in memory? If not, do as before, skip the records, copying them over to the next generation tape, until you found the one you are looking for.

Sorting was a crucial task in data processing in those days. With sequential access for most of the data, you had to have all your input records sorted the same way your master tape.  You have to sort with little or no random access auxiliary storage and little main memory.  That is why the process was called 'sort-merge'. You sorted as many records as your memory allowed and send them to as many tapes as you could gather.  Then, you would merge those separate batches of sorted records into larger and larger batches until you had the whole file sorted. Random access disk or drum units were invaluable in sorting, as they could make those batches so much larger.

You had to instruct the operator on all the tasks involved, the master tapes required, the output tapes produced, the auxiliary tapes needed, the order of the tasks to be performed.  Even in a large, multitasking system, you had to specify how much memory you would take, how much random storage space you needed, if there was any.   Disk files didn't grow automatically, you had to assign a contiguous fixed size.  If you asked for too much, you would be depriving others from those resources.  The operators would have to juggle with all that.  Tapes were numbered, the operator would have to check which tape number held the latest generation of the file requested. Someone had to go and pick the tape from the library and mount it.  The operator would have to tell the operating system which tape unit held the tape with each file, and it would have to keep a record which tape number would contain the new generation of a file.  Actually, there was a program to keep track of that tape library business.  Daily operations would have a regular schedule since resources were scarce. If your process required 4 tape drives and another 5, and you only had 6 tape drives, they could not be run in parallel.  Operators had to juggle with all that. 


----

Siendo un sistema mecánico, la unidad de cinta tiene inercia.  Tarda en arrancar y parar. Para reducir la inercia, el movimiento de la cinta sobre el cabezal se separaba del giro de los carretes. La cinta pasaba por algún tipo de mecanismo, por ejemplo, un brazo tensor o un tubo que succionaba la cinta, para que el cabrestante en el cabezal pudiera disponer de unos cuantos centímetros de cinta para su tira y afloja.  Los carretes giraban para reponer esa reserva de cinta, pero no afectaban al movimiento de la misma sobre el cabezal lector/grabador.

Aún así, el mecanismo requería de un espacio de frenado, es lo que le llamaban el *gap*, la brecha, un espacio entre un bloque de grabación y el siguiente.  Aquí aparece otro factor.  Una vez que se ponía la cinta en movimiento convenía leer lo más que se pudiera sin detenerse.  Por eso, la información no se grababa en *registros* sino en *bloques*.  Los clásicos registros de 80 caracteres, heredados de las tarjetas perforadas que tenían 80 columnas, se agrupaban en bloques de 512, 1024 ó 2048 caracteres.  De esa forma se minimizaba la cantidad de *gaps*.  De esa forma se podía tener, por ejemplo, un sólo *gap* cada 25 registros de 80 caracteres.  Un bloque era como enganchar una onda de semáforos en verde, hay que parar en el semáforo en rojo, pero cuantos más se puedan pasar en verde, mejor.

Cabe la pregunta, ¿por qué no se leía todo sin pausa?, o ¿por qué no bloques más largos?  Para lo primero, el problema es que los sistemas no siempre podían procesar registros a la velocidad a que la cinta podría girar. Para lo segundo, el problema es que las computadoras no tenían tanta memoria como para desperdiciar en bloques tan largos.

Por eso, también, es que no resulta práctico actualizar los datos en la misma cinta.  Primero porque obliga a la unidad a retroceder la cinta para regrabar el bloque.  Por seguridad, también hay que aumentar el *gap* para dar un mayor margen de error a la posición del bloque a regrabar, no fuera cosa que se solapara con el contiguo.  Y no conviene hacer bloques demasiado grandes si se va a actualizar. Bloques más chicos y *gaps* más largos hacen que la cinta no pueda almacenar tanta información.  En definitiva, no justifica.

Otro dato curioso es que en las cintas raramente se especificaba la capacidad de almacenamiento como se hace en una unidad de disco o en un pen-drive, pues esta varía muchísimo según el tamaño del bloque y el largo del *gap* que se use.


