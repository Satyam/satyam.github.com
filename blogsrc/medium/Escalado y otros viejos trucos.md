---
title: "Escalado y otros viejos¬†trucos"
date: "2024-11-06"
categories: ["Tecnolog√≠a","Historia"]
language: "es-ES"
draft: true
---
Al decir "escalado" no me refiero al ascenso a *"monta√±os"* üòâ sino a hacer c√°lculos dentro de un cierto rango de valores, para lo cual tiene que usarse un escala de conversi√≥n.

----

Es una t√©cnica que actualmente no se utiliza demasiado, dado que nuestros ordenadores tienen la capacidad para operar con cifras con cualquier precisi√≥n y, como programadores, simplemente expresamos la f√≥rmula que deseamos calcular en la notaci√≥n que corresponda al lenguaje de programaci√≥n que estemos usando. La velocidad de estos procesadores hacen que la demora en hacer estos c√°lculos pueda ser ignorada. Pero, no hace tanto tiempo, con procesadores m√°s lentos, no era realista hacer un c√°lculo sin pensar siquiera en lo que cada operaci√≥n aritm√©tica podr√≠a demorar.

Pero vamos a la base de nuestro problema. Como cualquier escolar sabe, hacer multiplicaciones y divisiones es m√°s trabajoso que hacer sumas y restas. Y ambas son m√°s complicadas cuantos m√°s d√≠gitos tengan las cifras con que operamos. La complejidad de una suma aumenta linealmente con la cantidad de cifras de los t√©rminos. La complejidad de una multiplicaci√≥n aumenta con el cuadrado de la longitud de las cifras. A los ordenadores les ocurre lo mismo. Y aunque no se cansan, frustran o equivocan como un escolar, no deja de consumir tiempo de procesamiento.

Para evitar empe√±ar demasiado tiempo en estas operaciones, lo habitual era planificarlas con antelaci√≥n y ver, realmente, cu√°ntos d√≠gitos era necesario calcular. No tiene sentido calcular 7 d√≠gitos de resultado cuando los operandos tienen un 1% de error. Es como calcular un corte en la madera para un mueble con precisi√≥n de d√©cimas de mil√≠metro para luego marcar la madera con un l√°piz con la punta roma.

Luego est√° el problema de usar 'punto flotante'. Los procesadores habitualmente hacen operaciones aritm√©ticas b√°sicas con n√∫meros enteros y para ello el programador puede destinar una cantidad predeterminada de bits para representar un valor entero. Con 8 bits podemos contar hasta 255, con 16 bits hasta 65.536, con 32 bits hasta 4.294.836.225 que parece mucho hasta que la canci√≥n Gangnam Style tuvo tantos visionados en YouTube que desbord√≥ los contadores. Ese es el gran problema de los enteros, si el n√∫mero se va fuera del rango previsto, da errores. Para eso est√° el 'punto flotante' en que la cifra se representa con una mantisa y exponente, por ejemplo, las cifras anteriores se pueden escribir como 2,55 x 10¬≤, 6,55 x 10‚Å¥ √≥ 4,29 x 10‚Åπ.

Para hacer operaciones con decimales, necesitan ayuda. Por ejemplo, todo escolar aprende las tablas de multiplicar, pero de d√≠gitos individuales. Aprendemos la tabla del 3 o la del 7 pero no aprendemos la tabla del 13 o del 7,5. Cuando tenemos que usar n√∫meros de varios d√≠gitos o con decimales, descomponemos la operaci√≥n en una serie de operaciones individuales, d√≠gito a d√≠gito y luego ajustamos los decimales, si cabe. Lo mismo le ocurre al procesador de un ordenador.

Si vemos la cronolog√≠a de los procesadores de la l√≠nea Intel 80x86, vemos que las sucesivas generaciones de chips, 8086, 80186, 80286 y 80386 operaban √∫nicamente con enteros, cualquier operaci√≥n de punto flotante se resolv√≠a con software o, si uno dispon√≠a de un mont√≥n de dinero, se le pod√≠a agregar un co-procesador num√©rico, que llevaba una numeraci√≥n similar al del procesador principal pero terminado en 7. En general el co-procesador num√©rico sal√≠a al mercado un par de a√±os despu√©s que el procesador base. Reci√©n con el 80486 incorporaron la circuiter√≠a necesaria para los c√°lculos en punto flotante directamente al chip principal pero, como eso lo encarec√≠a demasiado, Intel ofrec√≠a el 80486SX, que no hac√≠a punto flotante, a un precio m√°s bajo. A√∫n con el agregado de co-procesadores num√©ricos, los c√°lculos en punto flotante son relativamente lentos.

Por ello, las operaciones se hac√≠an, siempre que fuera posible, usando enteros. Por ejemplo, internamente los precios se expresaban en c√©ntimos, s√≥lo al imprimirlos se mostraban como unidades y c√©ntimos. Muchas cajas registradoras y otros peque√±os dispositivos electr√≥nicos destinados a comercios minoristas se manejaban en enteros, dado que habr√≠a sido muy costoso poner en un dispositivo de consumo masivo un microprocesador m√°s poderoso o m√°s memoria de programa para incluir operaciones de punto flotante.

Lo mismo ocurre con sensores industriales. Traducir la lectura de un transductor a un valor en unidades est√°ndares puede implicar varias operaciones. Por ejemplo, un sensor de velocidad de rotaci√≥n puede recibir un pulso por cada vuelta del eje de una m√°quina. Convertir el intervalo de tiempo entre pulsos sucesivos en revoluciones por minuto (RPM) requiere algunas cuentas, m√°s a√∫n si, como es habitual, se promedia a lo largo de varias lecturas sucesivas para evitar generar lecturas falsas por pulsos extra√±os o la falta de los mismos.¬†

Veamos un ejemplo concreto. En la Argentina, todos los alumnos de secundaria recib√≠amos una libreta de ahorro de la Caja Nacional de Ahorro Postal, que era una suerte de banco operado por el correo, donde cada oficina de correos era una suerte de sucursal bancaria y nuestros dep√≥sitos se convert√≠an en sellos en dicha libreta, importes que se pod√≠an retirar en cualquier otra oficina de correos. Yendo de acampada con los Boy Scouts, yo us√© mucho esa libreta para disponer de dinero en cualquier lugar del pa√≠s sin necesidad de llevar efectivo.¬†

En la escuela secundaria nos ense√±aron c√≥mo se calcula el inter√©s que nos pagaba la Caja por nuestros dep√≥sitos, supongo que para alentar el ahorro. La f√≥rmula era C (capital) por R (raz√≥n) por T (tiempo en d√≠as) dividido por 100 por 365. No s√© por qu√© se le llamaba "raz√≥n" pero b√°sicamente era el inter√©s anual del dep√≥sito, expresado en porcentaje, por eso luego se divid√≠a por 100. Si quer√≠as saber cu√°nto recibir√≠as por 100 pesos (o cualquier otra moneda) a un inter√©s del 3,5% durante un mes de 30 d√≠as, entonces era 100 * 3,5 * 30 / (100 * 365) = 0,29 pesos.

Imaginemos que hacemos esta cuenta usando enteros de 16 bits, lo cual nos da n√∫meros hasta 65535, simplemente para no enredarnos con cifras demasiado largas. Para empezar, como ya mencionamos, vamos a expresar los importes en c√©ntimos, para evitar los decimales. Igualmente, dado que el inter√©s puede llevar un decimal, en lugar de expresarlo en porcentaje lo vamos a expresar en "por mil". Convertiremos los 100 pesos en 10000 c√©ntimos y el 3,5 en 35.